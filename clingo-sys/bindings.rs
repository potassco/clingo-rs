/* automatically generated by rust-bindgen */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 30;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const CLINGO_VERSION_MAJOR: u32 = 5;
pub const CLINGO_VERSION_MINOR: u32 = 4;
pub const CLINGO_VERSION_REVISION: u32 = 1;
pub const CLINGO_VERSION: &'static [u8; 6usize] = b"5.4.1\0";
pub type wchar_t = ::std::os::raw::c_int;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = "! Signed integer type used for aspif and solver literals."]
pub type clingo_literal_t = i32;
#[doc = "! Unsigned integer type used for aspif atoms."]
pub type clingo_atom_t = u32;
#[doc = "! Unsigned integer type used in various places."]
pub type clingo_id_t = u32;
#[doc = "! Signed integer type for weights in sum aggregates and minimize constraints."]
pub type clingo_weight_t = i32;
#[doc = "! A Literal with an associated weight."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_weighted_literal {
    pub literal: clingo_literal_t,
    pub weight: clingo_weight_t,
}
#[test]
fn bindgen_test_layout_clingo_weighted_literal() {
    assert_eq!(
        ::std::mem::size_of::<clingo_weighted_literal>(),
        8usize,
        concat!("Size of: ", stringify!(clingo_weighted_literal))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_weighted_literal>(),
        4usize,
        concat!("Alignment of ", stringify!(clingo_weighted_literal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_weighted_literal>())).literal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_weighted_literal),
            "::",
            stringify!(literal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_weighted_literal>())).weight as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_weighted_literal),
            "::",
            stringify!(weight)
        )
    );
}
pub type clingo_weighted_literal_t = clingo_weighted_literal;
#[doc = "!< successful API calls"]
pub const clingo_error_clingo_error_success: clingo_error = 0;
#[doc = "!< errors only detectable at runtime like invalid input"]
pub const clingo_error_clingo_error_runtime: clingo_error = 1;
#[doc = "!< wrong usage of the clingo API"]
pub const clingo_error_clingo_error_logic: clingo_error = 2;
#[doc = "!< memory could not be allocated"]
pub const clingo_error_clingo_error_bad_alloc: clingo_error = 3;
#[doc = "!< errors unrelated to clingo"]
pub const clingo_error_clingo_error_unknown: clingo_error = 4;
#[doc = "! Enumeration of error codes."]
#[doc = "!"]
#[doc = "! @note Errors can only be recovered from if explicitly mentioned; most"]
#[doc = "! functions do not provide strong exception guarantees.  This means that in"]
#[doc = "! case of errors associated objects cannot be used further.  If such an"]
#[doc = "! object has a free function, this function can and should still be called."]
pub type clingo_error = u32;
#[doc = "! Corresponding type to ::clingo_error."]
pub type clingo_error_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! Convert error code into string."]
    pub fn clingo_error_string(code: clingo_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "! Get the last error code set by a clingo API call."]
    #[doc = "! @note Each thread has its own local error code."]
    #[doc = "! @return error code"]
    pub fn clingo_error_code() -> clingo_error_t;
}
extern "C" {
    #[doc = "! Get the last error message set if an API call fails."]
    #[doc = "! @note Each thread has its own local error message."]
    #[doc = "! @return error message or NULL"]
    pub fn clingo_error_message() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "! Set a custom error code and message in the active thread."]
    #[doc = "! @param[in] code the error code"]
    #[doc = "! @param[in] message the error message"]
    pub fn clingo_set_error(code: clingo_error_t, message: *const ::std::os::raw::c_char);
}
#[doc = "!< undefined arithmetic operation or weight of aggregate"]
pub const clingo_warning_clingo_warning_operation_undefined: clingo_warning = 0;
#[doc = "!< to report multiple errors; a corresponding runtime error is raised later"]
pub const clingo_warning_clingo_warning_runtime_error: clingo_warning = 1;
#[doc = "!< undefined atom in program"]
pub const clingo_warning_clingo_warning_atom_undefined: clingo_warning = 2;
#[doc = "!< same file included multiple times"]
pub const clingo_warning_clingo_warning_file_included: clingo_warning = 3;
#[doc = "!< CSP variable with unbounded domain"]
pub const clingo_warning_clingo_warning_variable_unbounded: clingo_warning = 4;
#[doc = "!< global variable in tuple of aggregate element"]
pub const clingo_warning_clingo_warning_global_variable: clingo_warning = 5;
#[doc = "!< other kinds of warnings"]
pub const clingo_warning_clingo_warning_other: clingo_warning = 6;
#[doc = "! Enumeration of warning codes."]
pub type clingo_warning = u32;
#[doc = "! Corresponding type to ::clingo_warning."]
pub type clingo_warning_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! Convert warning code into string."]
    pub fn clingo_warning_string(code: clingo_warning_t) -> *const ::std::os::raw::c_char;
}
#[doc = "! Callback to intercept warning messages."]
#[doc = "!"]
#[doc = "! @param[in] code associated warning code"]
#[doc = "! @param[in] message warning message"]
#[doc = "! @param[in] data user data for callback"]
#[doc = "!"]
#[doc = "! @see clingo_control_new()"]
#[doc = "! @see clingo_parse_term()"]
#[doc = "! @see clingo_parse_program()"]
pub type clingo_logger_t = ::std::option::Option<
    unsafe extern "C" fn(
        code: clingo_warning_t,
        message: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "! Obtain the clingo version."]
    #[doc = "!"]
    #[doc = "! @param[out] major major version number"]
    #[doc = "! @param[out] minor minor version number"]
    #[doc = "! @param[out] revision revision number"]
    pub fn clingo_version(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        revision: *mut ::std::os::raw::c_int,
    );
}
#[doc = "!< no truth value"]
pub const clingo_truth_value_clingo_truth_value_free: clingo_truth_value = 0;
#[doc = "!< true"]
pub const clingo_truth_value_clingo_truth_value_true: clingo_truth_value = 1;
#[doc = "!< false"]
pub const clingo_truth_value_clingo_truth_value_false: clingo_truth_value = 2;
#[doc = "! Represents three-valued truth values."]
pub type clingo_truth_value = u32;
#[doc = "! Corresponding type to ::clingo_truth_value."]
pub type clingo_truth_value_t = ::std::os::raw::c_int;
#[doc = "! Represents a source code location marking its beginnig and end."]
#[doc = "!"]
#[doc = "! @note Not all locations refer to physical files."]
#[doc = "! By convention, such locations use a name put in angular brackets as filename."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_location {
    #[doc = "!< the file where the location begins"]
    pub begin_file: *const ::std::os::raw::c_char,
    #[doc = "!< the file where the location ends"]
    pub end_file: *const ::std::os::raw::c_char,
    #[doc = "!< the line where the location begins"]
    pub begin_line: usize,
    #[doc = "!< the line where the location ends"]
    pub end_line: usize,
    #[doc = "!< the column where the location begins"]
    pub begin_column: usize,
    #[doc = "!< the column where the location ends"]
    pub end_column: usize,
}
#[test]
fn bindgen_test_layout_clingo_location() {
    assert_eq!(
        ::std::mem::size_of::<clingo_location>(),
        48usize,
        concat!("Size of: ", stringify!(clingo_location))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_location>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_location))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_location>())).begin_file as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(begin_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_location>())).end_file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(end_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_location>())).begin_line as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(begin_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_location>())).end_line as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(end_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_location>())).begin_column as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(begin_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_location>())).end_column as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_location),
            "::",
            stringify!(end_column)
        )
    );
}
pub type clingo_location_t = clingo_location;
#[doc = "! Represents a predicate signature."]
#[doc = "!"]
#[doc = "! Signatures have a name and an arity, and can be positive or negative (to"]
#[doc = "! represent classical negation)."]
pub type clingo_signature_t = u64;
extern "C" {
    #[doc = "! Create a new signature."]
    #[doc = "!"]
    #[doc = "! @param[in] name name of the signature"]
    #[doc = "! @param[in] arity arity of the signature"]
    #[doc = "! @param[in] positive false if the signature has a classical negation sign"]
    #[doc = "! @param[out] signature the resulting signature"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_signature_create(
        name: *const ::std::os::raw::c_char,
        arity: u32,
        positive: bool,
        signature: *mut clingo_signature_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name of a signature."]
    #[doc = "!"]
    #[doc = "! @param[in] signature the target signature"]
    #[doc = "! @return the name of the signature"]
    pub fn clingo_signature_name(signature: clingo_signature_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "! Get the arity of a signature."]
    #[doc = "!"]
    #[doc = "! @param[in] signature the target signature"]
    #[doc = "! @return the arity of the signature"]
    pub fn clingo_signature_arity(signature: clingo_signature_t) -> u32;
}
extern "C" {
    #[doc = "! Whether the signature is positive (is not classically negated)."]
    #[doc = "!"]
    #[doc = "! @param[in] signature the target signature"]
    #[doc = "! @return whether the signature has no sign"]
    pub fn clingo_signature_is_positive(signature: clingo_signature_t) -> bool;
}
extern "C" {
    #[doc = "! Whether the signature is negative (is classically negated)."]
    #[doc = "!"]
    #[doc = "! @param[in] signature the target signature"]
    #[doc = "! @return whether the signature has a sign"]
    pub fn clingo_signature_is_negative(signature: clingo_signature_t) -> bool;
}
extern "C" {
    #[doc = "! Check if two signatures are equal."]
    #[doc = "!"]
    #[doc = "! @param[in] a first signature"]
    #[doc = "! @param[in] b second signature"]
    #[doc = "! @return whether a == b"]
    pub fn clingo_signature_is_equal_to(a: clingo_signature_t, b: clingo_signature_t) -> bool;
}
extern "C" {
    #[doc = "! Check if a signature is less than another signature."]
    #[doc = "!"]
    #[doc = "! Signatures are compared first by sign (unsigned < signed), then by arity,"]
    #[doc = "! then by name."]
    #[doc = "!"]
    #[doc = "! @param[in] a first signature"]
    #[doc = "! @param[in] b second signature"]
    #[doc = "! @return whether a < b"]
    pub fn clingo_signature_is_less_than(a: clingo_signature_t, b: clingo_signature_t) -> bool;
}
extern "C" {
    #[doc = "! Calculate a hash code of a signature."]
    #[doc = "!"]
    #[doc = "! @param[in] signature the target signature"]
    #[doc = "! @return the hash code of the signature"]
    pub fn clingo_signature_hash(signature: clingo_signature_t) -> usize;
}
#[doc = "!< the <tt>\\#inf</tt> symbol"]
pub const clingo_symbol_type_clingo_symbol_type_infimum: clingo_symbol_type = 0;
#[doc = "!< a numeric symbol, e.g., `1`"]
pub const clingo_symbol_type_clingo_symbol_type_number: clingo_symbol_type = 1;
#[doc = "!< a string symbol, e.g., `\"a\"`"]
pub const clingo_symbol_type_clingo_symbol_type_string: clingo_symbol_type = 4;
#[doc = "!< a numeric symbol, e.g., `c`, `(1, \"a\")`, or `f(1,\"a\")`"]
pub const clingo_symbol_type_clingo_symbol_type_function: clingo_symbol_type = 5;
#[doc = "!< the <tt>\\#sup</tt> symbol"]
pub const clingo_symbol_type_clingo_symbol_type_supremum: clingo_symbol_type = 7;
#[doc = "! Enumeration of available symbol types."]
pub type clingo_symbol_type = u32;
#[doc = "! Corresponding type to ::clingo_symbol_type."]
pub type clingo_symbol_type_t = ::std::os::raw::c_int;
#[doc = "! Represents a symbol."]
#[doc = "!"]
#[doc = "! This includes numbers, strings, functions (including constants when"]
#[doc = "! arguments are empty and tuples when the name is empty), <tt>\\#inf</tt> and <tt>\\#sup</tt>."]
pub type clingo_symbol_t = u64;
extern "C" {
    #[doc = "! Construct a symbol representing a number."]
    #[doc = "!"]
    #[doc = "! @param[in] number the number"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    pub fn clingo_symbol_create_number(number: ::std::os::raw::c_int, symbol: *mut clingo_symbol_t);
}
extern "C" {
    #[doc = "! Construct a symbol representing \\#sup."]
    #[doc = "!"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    pub fn clingo_symbol_create_supremum(symbol: *mut clingo_symbol_t);
}
extern "C" {
    #[doc = "! Construct a symbol representing <tt>\\#inf</tt>."]
    #[doc = "!"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    pub fn clingo_symbol_create_infimum(symbol: *mut clingo_symbol_t);
}
extern "C" {
    #[doc = "! Construct a symbol representing a string."]
    #[doc = "!"]
    #[doc = "! @param[in] string the string"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_symbol_create_string(
        string: *const ::std::os::raw::c_char,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Construct a symbol representing an id."]
    #[doc = "!"]
    #[doc = "! @note This is just a shortcut for clingo_symbol_create_function() with"]
    #[doc = "! empty arguments."]
    #[doc = "!"]
    #[doc = "! @param[in] name the name"]
    #[doc = "! @param[in] positive whether the symbol has a classical negation sign"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_symbol_create_id(
        name: *const ::std::os::raw::c_char,
        positive: bool,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Construct a symbol representing a function or tuple."]
    #[doc = "!"]
    #[doc = "! @note To create tuples, the empty string has to be used as name."]
    #[doc = "!"]
    #[doc = "! @param[in] name the name of the function"]
    #[doc = "! @param[in] arguments the arguments of the function"]
    #[doc = "! @param[in] arguments_size the number of arguments"]
    #[doc = "! @param[in] positive whether the symbol has a classical negation sign"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_symbol_create_function(
        name: *const ::std::os::raw::c_char,
        arguments: *const clingo_symbol_t,
        arguments_size: usize,
        positive: bool,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of a symbol."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] number the resulting number"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_number"]
    pub fn clingo_symbol_number(
        symbol: clingo_symbol_t,
        number: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name of a symbol."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] name the resulting name"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function"]
    pub fn clingo_symbol_name(
        symbol: clingo_symbol_t,
        name: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string of a symbol."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] string the resulting string"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_string"]
    pub fn clingo_symbol_string(
        symbol: clingo_symbol_t,
        string: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a function is positive (does not have a sign)."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] positive the result"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function"]
    pub fn clingo_symbol_is_positive(symbol: clingo_symbol_t, positive: *mut bool) -> bool;
}
extern "C" {
    #[doc = "! Check if a function is negative (has a sign)."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] negative the result"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function"]
    pub fn clingo_symbol_is_negative(symbol: clingo_symbol_t, negative: *mut bool) -> bool;
}
extern "C" {
    #[doc = "! Get the arguments of a symbol."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] arguments the resulting arguments"]
    #[doc = "! @param[out] arguments_size the number of arguments"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function"]
    pub fn clingo_symbol_arguments(
        symbol: clingo_symbol_t,
        arguments: *mut *const clingo_symbol_t,
        arguments_size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the type of a symbol."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @return the type of the symbol"]
    pub fn clingo_symbol_type(symbol: clingo_symbol_t) -> clingo_symbol_type_t;
}
extern "C" {
    #[doc = "! Get the size of the string representation of a symbol (including the terminating 0)."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_symbol_to_string_size(symbol: clingo_symbol_t, size: *mut usize) -> bool;
}
extern "C" {
    #[doc = "! Get the string representation of a symbol."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @param[out] string the resulting string"]
    #[doc = "! @param[in] size the size of the string"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "!"]
    #[doc = "! @see clingo_symbol_to_string_size()"]
    pub fn clingo_symbol_to_string(
        symbol: clingo_symbol_t,
        string: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if two symbols are equal."]
    #[doc = "!"]
    #[doc = "! @param[in] a first symbol"]
    #[doc = "! @param[in] b second symbol"]
    #[doc = "! @return whether a == b"]
    pub fn clingo_symbol_is_equal_to(a: clingo_symbol_t, b: clingo_symbol_t) -> bool;
}
extern "C" {
    #[doc = "! Check if a symbol is less than another symbol."]
    #[doc = "!"]
    #[doc = "! Symbols are first compared by type.  If the types are equal, the values are"]
    #[doc = "! compared (where strings are compared using strcmp).  Functions are first"]
    #[doc = "! compared by signature and then lexicographically by arguments."]
    #[doc = "!"]
    #[doc = "! @param[in] a first symbol"]
    #[doc = "! @param[in] b second symbol"]
    #[doc = "! @return whether a < b"]
    pub fn clingo_symbol_is_less_than(a: clingo_symbol_t, b: clingo_symbol_t) -> bool;
}
extern "C" {
    #[doc = "! Calculate a hash code of a symbol."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the target symbol"]
    #[doc = "! @return the hash code of the symbol"]
    pub fn clingo_symbol_hash(symbol: clingo_symbol_t) -> usize;
}
extern "C" {
    #[doc = "! Internalize a string."]
    #[doc = "!"]
    #[doc = "! This functions takes a string as input and returns an equal unique string"]
    #[doc = "! that is (at the moment) not freed until the program is closed.  All strings"]
    #[doc = "! returned from clingo API functions are internalized and must not be freed."]
    #[doc = "!"]
    #[doc = "! @param[in] string the string to internalize"]
    #[doc = "! @param[out] result the internalized string"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_add_string(
        string: *const ::std::os::raw::c_char,
        result: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Parse a term in string form."]
    #[doc = "!"]
    #[doc = "! The result of this function is a symbol. The input term can contain"]
    #[doc = "! unevaluated functions, which are evaluated during parsing."]
    #[doc = "!"]
    #[doc = "! @param[in] string the string to parse"]
    #[doc = "! @param[in] logger optional logger to report warnings during parsing"]
    #[doc = "! @param[in] logger_data user data for the logger"]
    #[doc = "! @param[in] message_limit maximum number of times to call the logger"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if parsing fails"]
    pub fn clingo_parse_term(
        string: *const ::std::os::raw::c_char,
        logger: clingo_logger_t,
        logger_data: *mut ::std::os::raw::c_void,
        message_limit: ::std::os::raw::c_uint,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_symbolic_atoms {
    _unused: [u8; 0],
}
#[doc = "! Object to inspect symbolic atoms in a program---the relevant Herbrand base"]
#[doc = "! gringo uses to instantiate programs."]
#[doc = "!"]
#[doc = "! @see clingo_control_symbolic_atoms()"]
pub type clingo_symbolic_atoms_t = clingo_symbolic_atoms;
#[doc = "! Object to iterate over symbolic atoms."]
#[doc = "!"]
#[doc = "! Such an iterator either points to a symbolic atom within a sequence of"]
#[doc = "! symbolic atoms or to the end of the sequence."]
#[doc = "!"]
#[doc = "! @note Iterators are valid as long as the underlying sequence is not modified."]
#[doc = "! Operations that can change this sequence are ::clingo_control_ground(),"]
#[doc = "! ::clingo_control_cleanup(), and functions that modify the underlying"]
#[doc = "! non-ground program."]
pub type clingo_symbolic_atom_iterator_t = u64;
extern "C" {
    #[doc = "! Get the number of different atoms occurring in a logic program."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[out] size the number of atoms"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_size(
        atoms: *const clingo_symbolic_atoms_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get a forward iterator to the beginning of the sequence of all symbolic"]
    #[doc = "! atoms optionally restricted to a given signature."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] signature optional signature"]
    #[doc = "! @param[out] iterator the resulting iterator"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_begin(
        atoms: *const clingo_symbolic_atoms_t,
        signature: *const clingo_signature_t,
        iterator: *mut clingo_symbolic_atom_iterator_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Iterator pointing to the end of the sequence of symbolic atoms."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[out] iterator the resulting iterator"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_end(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: *mut clingo_symbolic_atom_iterator_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Find a symbolic atom given its symbolic representation."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] symbol the symbol to lookup"]
    #[doc = "! @param[out] iterator iterator pointing to the symbolic atom or to the end"]
    #[doc = "! of the sequence if no corresponding atom is found"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_find(
        atoms: *const clingo_symbolic_atoms_t,
        symbol: clingo_symbol_t,
        iterator: *mut clingo_symbolic_atom_iterator_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if two iterators point to the same element (or end of the sequence)."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] a the first iterator"]
    #[doc = "! @param[in] b the second iterator"]
    #[doc = "! @param[out] equal whether the two iterators are equal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_iterator_is_equal_to(
        atoms: *const clingo_symbolic_atoms_t,
        a: clingo_symbolic_atom_iterator_t,
        b: clingo_symbolic_atom_iterator_t,
        equal: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the symbolic representation of an atom."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] iterator iterator to the atom"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_symbol(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether an atom is a fact."]
    #[doc = "!"]
    #[doc = "! @note This does not determine if an atom is a cautious consequence. The"]
    #[doc = "! grounding or solving component's simplifications can only detect this in"]
    #[doc = "! some cases."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] iterator iterator to the atom"]
    #[doc = "! @param[out] fact whether the atom is a fact"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_is_fact(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        fact: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether an atom is external."]
    #[doc = "!"]
    #[doc = "! An atom is external if it has been defined using an external directive and"]
    #[doc = "! has not been released or defined by a rule."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] iterator iterator to the atom"]
    #[doc = "! @param[out] external whether the atom is a external"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_is_external(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        external: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Returns the (numeric) aspif literal corresponding to the given symbolic atom."]
    #[doc = "!"]
    #[doc = "! Such a literal can be mapped to a solver literal (see the \\ref Propagator"]
    #[doc = "! module) or be used in rules in aspif format (see the \\ref ProgramBuilder"]
    #[doc = "! module)."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] iterator iterator to the atom"]
    #[doc = "! @param[out] literal the associated literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_literal(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        literal: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of different predicate signatures used in the program."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[out] size the number of signatures"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_signatures_size(
        atoms: *const clingo_symbolic_atoms_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the predicate signatures occurring in a logic program."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[out] signatures the resulting signatures"]
    #[doc = "! @param[in] size the number of signatures"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if the size is too small"]
    #[doc = "!"]
    #[doc = "! @see clingo_symbolic_atoms_signatures_size()"]
    pub fn clingo_symbolic_atoms_signatures(
        atoms: *const clingo_symbolic_atoms_t,
        signatures: *mut clingo_signature_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an iterator to the next element in the sequence of symbolic atoms."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] iterator the current iterator"]
    #[doc = "! @param[out] next the succeeding iterator"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_next(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        next: *mut clingo_symbolic_atom_iterator_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether the given iterator points to some element with the sequence"]
    #[doc = "! of symbolic atoms or to the end of the sequence."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[in] iterator the iterator"]
    #[doc = "! @param[out] valid whether the iterator points to some element within the"]
    #[doc = "! sequence"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_symbolic_atoms_is_valid(
        atoms: *const clingo_symbolic_atoms_t,
        iterator: clingo_symbolic_atom_iterator_t,
        valid: *mut bool,
    ) -> bool;
}
#[doc = "! Callback function to inject symbols."]
#[doc = "!"]
#[doc = "! @param symbols array of symbols"]
#[doc = "! @param symbols_size size of the symbol array"]
#[doc = "! @param data user data of the callback"]
#[doc = "! @return whether the call was successful; might set one of the following error codes:"]
#[doc = "! - ::clingo_error_bad_alloc"]
#[doc = "! @see ::clingo_ground_callback_t"]
pub type clingo_symbol_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        symbols: *const clingo_symbol_t,
        symbols_size: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "!< a tuple term, e.g., `(1,2,3)`"]
pub const clingo_theory_term_type_clingo_theory_term_type_tuple: clingo_theory_term_type = 0;
#[doc = "!< a list term, e.g., `[1,2,3]`"]
pub const clingo_theory_term_type_clingo_theory_term_type_list: clingo_theory_term_type = 1;
#[doc = "!< a set term, e.g., `{1,2,3}`"]
pub const clingo_theory_term_type_clingo_theory_term_type_set: clingo_theory_term_type = 2;
#[doc = "!< a function term, e.g., `f(1,2,3)`"]
pub const clingo_theory_term_type_clingo_theory_term_type_function: clingo_theory_term_type = 3;
#[doc = "!< a number term, e.g., `42`"]
pub const clingo_theory_term_type_clingo_theory_term_type_number: clingo_theory_term_type = 4;
#[doc = "!< a symbol term, e.g., `c`"]
pub const clingo_theory_term_type_clingo_theory_term_type_symbol: clingo_theory_term_type = 5;
#[doc = "! Enumeration of theory term types."]
pub type clingo_theory_term_type = u32;
#[doc = "! Corresponding type to ::clingo_theory_term_type."]
pub type clingo_theory_term_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_theory_atoms {
    _unused: [u8; 0],
}
#[doc = "! Container that stores theory atoms, elements, and terms (see @ref clingo_control_theory_atoms())."]
pub type clingo_theory_atoms_t = clingo_theory_atoms;
extern "C" {
    #[doc = "! Get the type of the given theory term."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the term is stored"]
    #[doc = "! @param[in] term id of the term"]
    #[doc = "! @param[out] type the resulting type"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_term_type(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        type_: *mut clingo_theory_term_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of the given numeric theory term."]
    #[doc = "!"]
    #[doc = "! @pre The term must be of type ::clingo_theory_term_type_number."]
    #[doc = "! @param[in] atoms container where the term is stored"]
    #[doc = "! @param[in] term id of the term"]
    #[doc = "! @param[out] number the resulting number"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_term_number(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        number: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name of the given constant or function theory term."]
    #[doc = "!"]
    #[doc = "! @pre The term must be of type ::clingo_theory_term_type_function or ::clingo_theory_term_type_symbol."]
    #[doc = "! @param[in] atoms container where the term is stored"]
    #[doc = "! @param[in] term id of the term"]
    #[doc = "! @param[out] name the resulting name"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_term_name(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        name: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the arguments of the given function theory term."]
    #[doc = "!"]
    #[doc = "! @pre The term must be of type ::clingo_theory_term_type_function."]
    #[doc = "! @param[in] atoms container where the term is stored"]
    #[doc = "! @param[in] term id of the term"]
    #[doc = "! @param[out] arguments the resulting arguments in form of an array of term ids"]
    #[doc = "! @param[out] size the number of arguments"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_term_arguments(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        arguments: *mut *const clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of the string representation of the given theory term (including the terminating 0)."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the term is stored"]
    #[doc = "! @param[in] term id of the term"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_term_to_string_size(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string representation of the given theory term."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the term is stored"]
    #[doc = "! @param[in] term id of the term"]
    #[doc = "! @param[out] string the resulting string"]
    #[doc = "! @param[in] size the size of the string"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if the size is too small"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "!"]
    #[doc = "! @see clingo_theory_atoms_term_to_string_size()"]
    pub fn clingo_theory_atoms_term_to_string(
        atoms: *const clingo_theory_atoms_t,
        term: clingo_id_t,
        string: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the tuple (array of theory terms) of the given theory element."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the element is stored"]
    #[doc = "! @param[in] element id of the element"]
    #[doc = "! @param[out] tuple the resulting array of term ids"]
    #[doc = "! @param[out] size the number of term ids"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_element_tuple(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        tuple: *mut *const clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the condition (array of aspif literals) of the given theory element."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the element is stored"]
    #[doc = "! @param[in] element id of the element"]
    #[doc = "! @param[out] condition the resulting array of aspif literals"]
    #[doc = "! @param[out] size the number of term literals"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_element_condition(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        condition: *mut *const clingo_literal_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the id of the condition of the given theory element."]
    #[doc = "!"]
    #[doc = "! @note"]
    #[doc = "! This id can be mapped to a solver literal using clingo_propagate_init_solver_literal()."]
    #[doc = "! This id is not (necessarily) an aspif literal;"]
    #[doc = "! to get aspif literals use clingo_theory_atoms_element_condition()."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the element is stored"]
    #[doc = "! @param[in] element id of the element"]
    #[doc = "! @param[out] condition the resulting condition id"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_element_condition_id(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        condition: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of the string representation of the given theory element (including the terminating 0)."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the element is stored"]
    #[doc = "! @param[in] element id of the element"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_element_to_string_size(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string representation of the given theory element."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the element is stored"]
    #[doc = "! @param[in] element id of the element"]
    #[doc = "! @param[out] string the resulting string"]
    #[doc = "! @param[in] size the size of the string"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if the size is too small"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_element_to_string(
        atoms: *const clingo_theory_atoms_t,
        element: clingo_id_t,
        string: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the total number of theory atoms."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the target"]
    #[doc = "! @param[out] size the resulting number"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_size(atoms: *const clingo_theory_atoms_t, size: *mut usize) -> bool;
}
extern "C" {
    #[doc = "! Get the theory term associated with the theory atom."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the atom is stored"]
    #[doc = "! @param[in] atom id of the atom"]
    #[doc = "! @param[out] term the resulting term id"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_term(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        term: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the theory elements associated with the theory atom."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the atom is stored"]
    #[doc = "! @param[in] atom id of the atom"]
    #[doc = "! @param[out] elements the resulting array of elements"]
    #[doc = "! @param[out] size the number of elements"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_elements(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        elements: *mut *const clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Whether the theory atom has a guard."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the atom is stored"]
    #[doc = "! @param[in] atom id of the atom"]
    #[doc = "! @param[out] has_guard whether the theory atom has a guard"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_has_guard(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        has_guard: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the guard consisting of a theory operator and a theory term of the given theory atom."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the atom is stored"]
    #[doc = "! @param[in] atom id of the atom"]
    #[doc = "! @param[out] connective the resulting theory operator"]
    #[doc = "! @param[out] term the resulting term"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_guard(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        connective: *mut *const ::std::os::raw::c_char,
        term: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the aspif literal associated with the given theory atom."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the atom is stored"]
    #[doc = "! @param[in] atom id of the atom"]
    #[doc = "! @param[out] literal the resulting literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_theory_atoms_atom_literal(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        literal: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of the string representation of the given theory atom (including the terminating 0)."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the atom is stored"]
    #[doc = "! @param[in] atom id of the element"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_atom_to_string_size(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string representation of the given theory atom."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms container where the atom is stored"]
    #[doc = "! @param[in] atom id of the element"]
    #[doc = "! @param[out] string the resulting string"]
    #[doc = "! @param[in] size the size of the string"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if the size is too small"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_theory_atoms_atom_to_string(
        atoms: *const clingo_theory_atoms_t,
        atom: clingo_id_t,
        string: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_assignment {
    _unused: [u8; 0],
}
#[doc = "! Represents a (partial) assignment of a particular solver."]
#[doc = "!"]
#[doc = "! An assignment assigns truth values to a set of literals."]
#[doc = "! A literal is assigned to either @link clingo_assignment_truth_value() true or false, or is unassigned@endlink."]
#[doc = "! Furthermore, each assigned literal is associated with a @link clingo_assignment_level() decision level@endlink."]
#[doc = "! There is exactly one @link clingo_assignment_decision() decision literal@endlink for each decision level greater than zero."]
#[doc = "! Assignments to all other literals on the same level are consequences implied by the current and possibly previous decisions."]
#[doc = "! Assignments on level zero are immediate consequences of the current program."]
#[doc = "! Decision levels are consecutive numbers starting with zero up to and including the @link clingo_assignment_decision_level() current decision level@endlink."]
pub type clingo_assignment_t = clingo_assignment;
extern "C" {
    #[doc = "! Get the current decision level."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @return the decision level"]
    pub fn clingo_assignment_decision_level(assignment: *const clingo_assignment_t) -> u32;
}
extern "C" {
    #[doc = "! Get the current root level."]
    #[doc = "!"]
    #[doc = "! Decisions levels smaller or equal to the root level are not backtracked during solving."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @return the decision level"]
    pub fn clingo_assignment_root_level(assignment: *const clingo_assignment_t) -> u32;
}
extern "C" {
    #[doc = "! Check if the given assignment is conflicting."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @return whether the assignment is conflicting"]
    pub fn clingo_assignment_has_conflict(assignment: *const clingo_assignment_t) -> bool;
}
extern "C" {
    #[doc = "! Check if the given literal is part of a (partial) assignment."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @param[in] literal the literal"]
    #[doc = "! @return whether the literal is valid"]
    pub fn clingo_assignment_has_literal(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Determine the decision level of a given literal."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @param[in] literal the literal"]
    #[doc = "! @param[out] level the resulting level"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_assignment_level(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        level: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = "! Determine the decision literal given a decision level."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @param[in] level the level"]
    #[doc = "! @param[out] literal the resulting literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_assignment_decision(
        assignment: *const clingo_assignment_t,
        level: u32,
        literal: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a literal has a fixed truth value."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @param[in] literal the literal"]
    #[doc = "! @param[out] is_fixed whether the literal is fixed"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_assignment_is_fixed(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        is_fixed: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a literal is true."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @param[in] literal the literal"]
    #[doc = "! @param[out] is_true whether the literal is true"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "! @see clingo_assignment_truth_value()"]
    pub fn clingo_assignment_is_true(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        is_true: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a literal has a fixed truth value."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @param[in] literal the literal"]
    #[doc = "! @param[out] is_false whether the literal is false"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "! @see clingo_assignment_truth_value()"]
    pub fn clingo_assignment_is_false(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        is_false: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Determine the truth value of a given literal."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target assignment"]
    #[doc = "! @param[in] literal the literal"]
    #[doc = "! @param[out] value the resulting truth value"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_assignment_truth_value(
        assignment: *const clingo_assignment_t,
        literal: clingo_literal_t,
        value: *mut clingo_truth_value_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! The number of assigned literals in the assignment."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target"]
    #[doc = "! @return the number of literals"]
    pub fn clingo_assignment_size(assignment: *const clingo_assignment_t) -> usize;
}
extern "C" {
    #[doc = "! The maximum size of the assignment (if all literals are assigned)."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target"]
    #[doc = "! @return the maximum size"]
    pub fn clingo_assignment_max_size(assignment: *const clingo_assignment_t) -> usize;
}
extern "C" {
    #[doc = "! Check if the assignmen is total, i.e. - size == max_size."]
    #[doc = "!"]
    #[doc = "! @param[in] assignment the target"]
    #[doc = "! @return wheather the assignment is total"]
    pub fn clingo_assignment_is_total(assignment: *const clingo_assignment_t) -> bool;
}
#[doc = "!< do not call @ref ::clingo_propagator::check() at all"]
pub const clingo_propagator_check_mode_clingo_propagator_check_mode_none:
    clingo_propagator_check_mode = 0;
#[doc = "!< call @ref ::clingo_propagator::check() on total assignment"]
pub const clingo_propagator_check_mode_clingo_propagator_check_mode_total:
    clingo_propagator_check_mode = 1;
#[doc = "!< call @ref ::clingo_propagator::check() on propagation fixpoints"]
pub const clingo_propagator_check_mode_clingo_propagator_check_mode_fixpoint:
    clingo_propagator_check_mode = 2;
#[doc = "! Supported check modes for propagators."]
pub type clingo_propagator_check_mode = u32;
#[doc = "! Corresponding type to ::clingo_propagator_check_mode."]
pub type clingo_propagator_check_mode_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_propagate_init {
    _unused: [u8; 0],
}
#[doc = "! Object to initialize a user-defined propagator before each solving step."]
#[doc = "!"]
#[doc = "! Each @link SymbolicAtoms symbolic@endlink or @link TheoryAtoms theory atom@endlink is uniquely associated with an aspif atom in form of a positive integer (@ref ::clingo_literal_t)."]
#[doc = "! Aspif literals additionally are signed to represent default negation."]
#[doc = "! Furthermore, there are non-zero integer solver literals (also represented using @ref ::clingo_literal_t)."]
#[doc = "! There is a surjective mapping from program atoms to solver literals."]
#[doc = "!"]
#[doc = "! All methods called during propagation use solver literals whereas clingo_symbolic_atoms_literal() and clingo_theory_atoms_atom_literal() return program literals."]
#[doc = "! The function clingo_propagate_init_solver_literal() can be used to map program literals or @link clingo_theory_atoms_element_condition_id() condition ids@endlink to solver literals."]
pub type clingo_propagate_init_t = clingo_propagate_init;
extern "C" {
    #[doc = "! Map the given program literal or condition id to its solver literal."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] aspif_literal the aspif literal to map"]
    #[doc = "! @param[out] solver_literal the resulting solver literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_propagate_init_solver_literal(
        init: *const clingo_propagate_init_t,
        aspif_literal: clingo_literal_t,
        solver_literal: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a watch for the solver literal in the given phase."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] solver_literal the solver literal"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_propagate_init_add_watch(
        init: *mut clingo_propagate_init_t,
        solver_literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a watch for the solver literal in the given phase to the given solver thread."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] solver_literal the solver literal"]
    #[doc = "! @param[in] thread_id the id of the solver thread"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_propagate_init_add_watch_to_thread(
        init: *mut clingo_propagate_init_t,
        solver_literal: clingo_literal_t,
        thread_id: clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect the symbolic atoms."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[out] atoms the resulting object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_propagate_init_symbolic_atoms(
        init: *const clingo_propagate_init_t,
        atoms: *mut *const clingo_symbolic_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect the theory atoms."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[out] atoms the resulting object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_propagate_init_theory_atoms(
        init: *const clingo_propagate_init_t,
        atoms: *mut *const clingo_theory_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of threads used in subsequent solving."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @return the number of threads"]
    #[doc = "! @see clingo_propagate_control_thread_id()"]
    pub fn clingo_propagate_init_number_of_threads(
        init: *const clingo_propagate_init_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "! Configure when to call the check method of the propagator."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] mode bitmask when to call the propagator"]
    #[doc = "! @see @ref ::clingo_propagator::check()"]
    pub fn clingo_propagate_init_set_check_mode(
        init: *mut clingo_propagate_init_t,
        mode: clingo_propagator_check_mode_t,
    );
}
extern "C" {
    #[doc = "! Get the current check mode of the propagator."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @return bitmask when to call the propagator"]
    #[doc = "! @see clingo_propagate_init_set_check_mode()"]
    pub fn clingo_propagate_init_get_check_mode(
        init: *const clingo_propagate_init_t,
    ) -> clingo_propagator_check_mode_t;
}
extern "C" {
    #[doc = "! Get the top level assignment solver."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @return the assignment"]
    pub fn clingo_propagate_init_assignment(
        init: *const clingo_propagate_init_t,
    ) -> *const clingo_assignment_t;
}
extern "C" {
    #[doc = "! Add a literal to the solver."]
    #[doc = "!"]
    #[doc = "! @attention If varibales were added, subsequent calls to functions adding constraints or ::clingo_propagate_init_propagate() are expensive."]
    #[doc = "! It is best to add varables in batches."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[out] result the added literal"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_add_literal(
        init: *mut clingo_propagate_init_t,
        result: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add the given clause to the solver."]
    #[doc = "!"]
    #[doc = "! @attention No further calls on the init object or functions on the assignment should be called when the result of this method is false."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] clause the clause to add"]
    #[doc = "! @param[in] size the size of the clause"]
    #[doc = "! @param[out] result result indicating whether the problem became unsatisfiable"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_add_clause(
        init: *mut clingo_propagate_init_t,
        clause: *const clingo_literal_t,
        size: usize,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add the given weight constraint to the solver."]
    #[doc = "!"]
    #[doc = "! This function adds a constraint of form `literal == { lit=weight | (lit, weight) in literals } <= bound` to the solver."]
    #[doc = "!"]
    #[doc = "! @attention No further calls on the init object or functions on the assignment should be called when the result of this method is false."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] literal the literal of the constraint"]
    #[doc = "! @param[in] literals the weighted literals"]
    #[doc = "! @param[in] size the number of weighted literals"]
    #[doc = "! @param[in] bound the bound of the constraint"]
    #[doc = "! @param[in] compare_equal if true compare equal instead of less than equal"]
    #[doc = "! @param[out] result result indicating whether the problem became unsatisfiable"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_add_weight_constraint(
        init: *mut clingo_propagate_init_t,
        literal: clingo_literal_t,
        literals: *const clingo_weighted_literal_t,
        size: usize,
        bound: clingo_weight_t,
        compare_equal: bool,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add the given literal to minimize to the solver."]
    #[doc = "!"]
    #[doc = "! This corresponds to a weak constraint of form `:~ literal. [weight@priority]`."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[in] literal the literal to minimize"]
    #[doc = "! @param[in] weight the weight of the literal"]
    #[doc = "! @param[in] priority the priority of the literal"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_add_minimize(
        init: *mut clingo_propagate_init_t,
        literal: clingo_literal_t,
        weight: clingo_weight_t,
        priority: clingo_weight_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Propagates consequences of the underlying problem excluding registered propagators."]
    #[doc = "!"]
    #[doc = "! @note The function has no effect if SAT-preprocessing is enabled."]
    #[doc = "! @attention No further calls on the init object or functions on the assignment should be called when the result of this method is false."]
    #[doc = "!"]
    #[doc = "! @param[in] init the target"]
    #[doc = "! @param[out] result result indicating whether the problem became unsatisfiable"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_init_propagate(
        init: *mut clingo_propagate_init_t,
        result: *mut bool,
    ) -> bool;
}
#[doc = "!< clause is subject to the solvers deletion policy"]
pub const clingo_clause_type_clingo_clause_type_learnt: clingo_clause_type = 0;
#[doc = "!< clause is not subject to the solvers deletion policy"]
pub const clingo_clause_type_clingo_clause_type_static: clingo_clause_type = 1;
#[doc = "!< like ::clingo_clause_type_learnt but the clause is deleted after a solving step"]
pub const clingo_clause_type_clingo_clause_type_volatile: clingo_clause_type = 2;
#[doc = "!< like ::clingo_clause_type_static but the clause is deleted after a solving step"]
pub const clingo_clause_type_clingo_clause_type_volatile_static: clingo_clause_type = 3;
#[doc = "! Enumeration of clause types determining the lifetime of a clause."]
#[doc = "!"]
#[doc = "! Clauses in the solver are either cleaned up based on a configurable deletion policy or at the end of a solving step."]
#[doc = "! The values of this enumeration determine if a clause is subject to one of the above deletion strategies."]
pub type clingo_clause_type = u32;
#[doc = "! Corresponding type to ::clingo_clause_type."]
pub type clingo_clause_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_propagate_control {
    _unused: [u8; 0],
}
#[doc = "! This object can be used to add clauses and propagate literals while solving."]
pub type clingo_propagate_control_t = clingo_propagate_control;
extern "C" {
    #[doc = "! Get the id of the underlying solver thread."]
    #[doc = "!"]
    #[doc = "! Thread ids are consecutive numbers starting with zero."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @return the thread id"]
    pub fn clingo_propagate_control_thread_id(
        control: *const clingo_propagate_control_t,
    ) -> clingo_id_t;
}
extern "C" {
    #[doc = "! Get the assignment associated with the underlying solver."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @return the assignment"]
    pub fn clingo_propagate_control_assignment(
        control: *const clingo_propagate_control_t,
    ) -> *const clingo_assignment_t;
}
extern "C" {
    #[doc = "! Adds a new volatile literal to the underlying solver thread."]
    #[doc = "!"]
    #[doc = "! @attention The literal is only valid within the current solving step and solver thread."]
    #[doc = "! All volatile literals and clauses involving a volatile literal are deleted after the current search."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] result the (positive) solver literal"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_logic if the assignment is conflicting"]
    pub fn clingo_propagate_control_add_literal(
        control: *mut clingo_propagate_control_t,
        result: *mut clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a watch for the solver literal in the given phase."]
    #[doc = "!"]
    #[doc = "! @note Unlike @ref clingo_propagate_init_add_watch() this does not add a watch to all solver threads but just the current one."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] literal the literal to watch"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_logic if the literal is invalid"]
    #[doc = "! @see clingo_propagate_control_remove_watch()"]
    pub fn clingo_propagate_control_add_watch(
        control: *mut clingo_propagate_control_t,
        literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether a literal is watched in the current solver thread."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] literal the literal to check"]
    #[doc = "!"]
    #[doc = "! @return whether the literal is watched"]
    pub fn clingo_propagate_control_has_watch(
        control: *const clingo_propagate_control_t,
        literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Removes the watch (if any) for the given solver literal."]
    #[doc = "!"]
    #[doc = "! @note Similar to @ref clingo_propagate_init_add_watch() this just removes the watch in the current solver thread."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] literal the literal to remove"]
    pub fn clingo_propagate_control_remove_watch(
        control: *mut clingo_propagate_control_t,
        literal: clingo_literal_t,
    );
}
extern "C" {
    #[doc = "! Add the given clause to the solver."]
    #[doc = "!"]
    #[doc = "! This method sets its result to false if the current propagation must be stopped for the solver to backtrack."]
    #[doc = "!"]
    #[doc = "! @attention No further calls on the control object or functions on the assignment should be called when the result of this method is false."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] clause the clause to add"]
    #[doc = "! @param[in] size the size of the clause"]
    #[doc = "! @param[in] type the clause type determining its lifetime"]
    #[doc = "! @param[out] result result indicating whether propagation has to be stopped"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_control_add_clause(
        control: *mut clingo_propagate_control_t,
        clause: *const clingo_literal_t,
        size: usize,
        type_: clingo_clause_type_t,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Propagate implied literals (resulting from added clauses)."]
    #[doc = "!"]
    #[doc = "! This method sets its result to false if the current propagation must be stopped for the solver to backtrack."]
    #[doc = "!"]
    #[doc = "! @attention No further calls on the control object or functions on the assignment should be called when the result of this method is false."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] result result indicating whether propagation has to be stopped"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_propagate_control_propagate(
        control: *mut clingo_propagate_control_t,
        result: *mut bool,
    ) -> bool;
}
#[doc = "! Typedef for @ref ::clingo_propagator::init()."]
pub type clingo_propagator_init_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut clingo_propagate_init_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! Typedef for @ref ::clingo_propagator::propagate()."]
pub type clingo_propagator_propagate_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut clingo_propagate_control_t,
        arg2: *const clingo_literal_t,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! Typedef for @ref ::clingo_propagator::undo()."]
pub type clingo_propagator_undo_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const clingo_propagate_control_t,
        arg2: *const clingo_literal_t,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! Typedef for @ref ::clingo_propagator::check()."]
pub type clingo_propagator_check_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut clingo_propagate_control_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! An instance of this struct has to be registered with a solver to implement a custom propagator."]
#[doc = "!"]
#[doc = "! Not all callbacks have to be implemented and can be set to NULL if not needed."]
#[doc = "! @see Propagator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_propagator {
    #[doc = "! This function is called once before each solving step."]
    #[doc = "! It is used to map relevant program literals to solver literals, add watches for solver literals, and initialize the data structures used during propagation."]
    #[doc = "!"]
    #[doc = "! @note This is the last point to access symbolic and theory atoms."]
    #[doc = "! Once the search has started, they are no longer accessible."]
    #[doc = "!"]
    #[doc = "! @param[in] init initizialization object"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "! @see ::clingo_propagator_init_callback_t"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            init: *mut clingo_propagate_init_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Can be used to propagate solver literals given a @link clingo_assignment_t partial assignment@endlink."]
    #[doc = "!"]
    #[doc = "! Called during propagation with a non-empty array of @link clingo_propagate_init_add_watch() watched solver literals@endlink"]
    #[doc = "! that have been assigned to true since the last call to either propagate, undo, (or the start of the search) - the change set."]
    #[doc = "! Only watched solver literals are contained in the change set."]
    #[doc = "! Each literal in the change set is true w.r.t. the current @link clingo_assignment_t assignment@endlink."]
    #[doc = "! @ref clingo_propagate_control_add_clause() can be used to add clauses."]
    #[doc = "! If a clause is unit resulting, it can be propagated using @ref clingo_propagate_control_propagate()."]
    #[doc = "! If the result of either of the two methods is false, the propagate function must return immediately."]
    #[doc = "!"]
    #[doc = "! The following snippet shows how to use the methods to add clauses and propagate consequences within the callback."]
    #[doc = "! The important point is to return true (true to indicate there was no error) if the result of either of the methods is false."]
    #[doc = "! ~~~~~~~~~~~~~~~{.c}"]
    #[doc = "! bool result;"]
    #[doc = "! clingo_literal_t clause[] = { ... };"]
    #[doc = "!"]
    #[doc = "! // add a clause"]
    #[doc = "! if (!clingo_propagate_control_add_clause(control, clause, clingo_clause_type_learnt, &result) { return false; }"]
    #[doc = "! if (!result) { return true; }"]
    #[doc = "! // propagate its consequences"]
    #[doc = "! if (!clingo_propagate_control_propagate(control, &result) { return false; }"]
    #[doc = "! if (!result) { return true; }"]
    #[doc = "!"]
    #[doc = "! // add further clauses and propagate them"]
    #[doc = "! ..."]
    #[doc = "!"]
    #[doc = "! return true;"]
    #[doc = "! ~~~~~~~~~~~~~~~"]
    #[doc = "!"]
    #[doc = "! @note"]
    #[doc = "! This function can be called from different solving threads."]
    #[doc = "! Each thread has its own assignment and id, which can be obtained using @ref clingo_propagate_control_thread_id()."]
    #[doc = "!"]
    #[doc = "! @param[in] control control object for the target solver"]
    #[doc = "! @param[in] changes the change set"]
    #[doc = "! @param[in] size the size of the change set"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "! @see ::clingo_propagator_propagate_callback_t"]
    pub propagate: ::std::option::Option<
        unsafe extern "C" fn(
            control: *mut clingo_propagate_control_t,
            changes: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Called whenever a solver undoes assignments to watched solver literals."]
    #[doc = "!"]
    #[doc = "! This callback is meant to update assignment dependent state in the propagator."]
    #[doc = "!"]
    #[doc = "! @note No clauses must be propagated in this callback."]
    #[doc = "!"]
    #[doc = "! @param[in] control control object for the target solver"]
    #[doc = "! @param[in] changes the change set"]
    #[doc = "! @param[in] size the size of the change set"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "! @see ::clingo_propagator_undo_callback_t"]
    pub undo: ::std::option::Option<
        unsafe extern "C" fn(
            control: *const clingo_propagate_control_t,
            changes: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! This function is similar to @ref clingo_propagate_control_propagate() but is called without a change set on propagation fixpoints."]
    #[doc = "!"]
    #[doc = "! When exactly this function is called, can be configured using the @ref clingo_propagate_init_set_check_mode() function."]
    #[doc = "!"]
    #[doc = "! @note This function is called even if no watches have been added."]
    #[doc = "!"]
    #[doc = "! @param[in] control control object for the target solver"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "! @see ::clingo_propagator_check_callback_t"]
    pub check: ::std::option::Option<
        unsafe extern "C" fn(
            control: *mut clingo_propagate_control_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! This function allows a propagator to implement domain-specific heuristics."]
    #[doc = "!"]
    #[doc = "! It is called whenever propagation reaches a fixed point and"]
    #[doc = "! should return a free solver literal that is to be assigned true."]
    #[doc = "! In case multiple propagators are registered,"]
    #[doc = "! this function can return 0 to let a propagator registered later make a decision."]
    #[doc = "! If all propagators return 0, then the fallback literal is"]
    #[doc = "!"]
    #[doc = "! @param[in] thread_id the solver's thread id"]
    #[doc = "! @param[in] assignment the assignment of the solver"]
    #[doc = "! @param[in] fallback the literal choosen by the solver's heuristic"]
    #[doc = "! @param[out] decision the literal to make true"]
    #[doc = "! @return whether the call was successful"]
    pub decide: ::std::option::Option<
        unsafe extern "C" fn(
            thread_id: clingo_id_t,
            assignment: *const clingo_assignment_t,
            fallback: clingo_literal_t,
            data: *mut ::std::os::raw::c_void,
            decision: *mut clingo_literal_t,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_clingo_propagator() {
    assert_eq!(
        ::std::mem::size_of::<clingo_propagator>(),
        40usize,
        concat!("Size of: ", stringify!(clingo_propagator))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_propagator>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_propagator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_propagator>())).init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_propagator>())).propagate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(propagate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_propagator>())).undo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(undo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_propagator>())).check as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_propagator>())).decide as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_propagator),
            "::",
            stringify!(decide)
        )
    );
}
pub type clingo_propagator_t = clingo_propagator;
#[doc = "!< set the level of an atom"]
pub const clingo_heuristic_type_clingo_heuristic_type_level: clingo_heuristic_type = 0;
#[doc = "!< configure which sign to chose for an atom"]
pub const clingo_heuristic_type_clingo_heuristic_type_sign: clingo_heuristic_type = 1;
#[doc = "!< modify VSIDS factor of an atom"]
pub const clingo_heuristic_type_clingo_heuristic_type_factor: clingo_heuristic_type = 2;
#[doc = "!< modify the initial VSIDS score of an atom"]
pub const clingo_heuristic_type_clingo_heuristic_type_init: clingo_heuristic_type = 3;
#[doc = "!< set the level of an atom and choose a positive sign"]
pub const clingo_heuristic_type_clingo_heuristic_type_true: clingo_heuristic_type = 4;
#[doc = "!< set the level of an atom and choose a negative sign"]
pub const clingo_heuristic_type_clingo_heuristic_type_false: clingo_heuristic_type = 5;
#[doc = "! Enumeration of different heuristic modifiers."]
#[doc = "! @ingroup ProgramInspection"]
pub type clingo_heuristic_type = u32;
#[doc = "! Corresponding type to ::clingo_heuristic_type."]
#[doc = "! @ingroup ProgramInspection"]
pub type clingo_heuristic_type_t = ::std::os::raw::c_int;
#[doc = "!< allow an external to be assigned freely"]
pub const clingo_external_type_clingo_external_type_free: clingo_external_type = 0;
#[doc = "!< assign an external to true"]
pub const clingo_external_type_clingo_external_type_true: clingo_external_type = 1;
#[doc = "!< assign an external to false"]
pub const clingo_external_type_clingo_external_type_false: clingo_external_type = 2;
#[doc = "!< no longer treat an atom as external"]
pub const clingo_external_type_clingo_external_type_release: clingo_external_type = 3;
#[doc = "! Enumeration of different external statements."]
#[doc = "! @ingroup ProgramInspection"]
pub type clingo_external_type = u32;
#[doc = "! Corresponding type to ::clingo_external_type."]
#[doc = "! @ingroup ProgramInspection"]
pub type clingo_external_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_backend {
    _unused: [u8; 0],
}
#[doc = "! Handle to the backend to add directives in aspif format."]
pub type clingo_backend_t = clingo_backend;
extern "C" {
    #[doc = "! Prepare the backend for usage."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_backend_begin(backend: *mut clingo_backend_t) -> bool;
}
extern "C" {
    #[doc = "! Finalize the backend after using it."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime"]
    pub fn clingo_backend_end(backend: *mut clingo_backend_t) -> bool;
}
extern "C" {
    #[doc = "! Add a rule to the program."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] choice determines if the head is a choice or a disjunction"]
    #[doc = "! @param[in] head the head atoms"]
    #[doc = "! @param[in] head_size the number of atoms in the head"]
    #[doc = "! @param[in] body the body literals"]
    #[doc = "! @param[in] body_size the number of literals in the body"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_rule(
        backend: *mut clingo_backend_t,
        choice: bool,
        head: *const clingo_atom_t,
        head_size: usize,
        body: *const clingo_literal_t,
        body_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a weight rule to the program."]
    #[doc = "!"]
    #[doc = "! @attention All weights and the lower bound must be positive."]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] choice determines if the head is a choice or a disjunction"]
    #[doc = "! @param[in] head the head atoms"]
    #[doc = "! @param[in] head_size the number of atoms in the head"]
    #[doc = "! @param[in] lower_bound the lower bound of the weight rule"]
    #[doc = "! @param[in] body the weighted body literals"]
    #[doc = "! @param[in] body_size the number of weighted literals in the body"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_weight_rule(
        backend: *mut clingo_backend_t,
        choice: bool,
        head: *const clingo_atom_t,
        head_size: usize,
        lower_bound: clingo_weight_t,
        body: *const clingo_weighted_literal_t,
        body_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a minimize constraint (or weak constraint) to the program."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] priority the priority of the constraint"]
    #[doc = "! @param[in] literals the weighted literals whose sum to minimize"]
    #[doc = "! @param[in] size the number of weighted literals"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_minimize(
        backend: *mut clingo_backend_t,
        priority: clingo_weight_t,
        literals: *const clingo_weighted_literal_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a projection directive."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] atoms the atoms to project on"]
    #[doc = "! @param[in] size the number of atoms"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_project(
        backend: *mut clingo_backend_t,
        atoms: *const clingo_atom_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an external statement."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] atom the external atom"]
    #[doc = "! @param[in] type the type of the external statement"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_external(
        backend: *mut clingo_backend_t,
        atom: clingo_atom_t,
        type_: clingo_external_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an assumption directive."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] literals the literals to assume (positive literals are true and negative literals false for the next solve call)"]
    #[doc = "! @param[in] size the number of atoms"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_assume(
        backend: *mut clingo_backend_t,
        literals: *const clingo_literal_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an heuristic directive."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] atom the target atom"]
    #[doc = "! @param[in] type the type of the heuristic modification"]
    #[doc = "! @param[in] bias the heuristic bias"]
    #[doc = "! @param[in] priority the heuristic priority"]
    #[doc = "! @param[in] condition the condition under which to apply the heuristic modification"]
    #[doc = "! @param[in] size the number of atoms in the condition"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_heuristic(
        backend: *mut clingo_backend_t,
        atom: clingo_atom_t,
        type_: clingo_heuristic_type_t,
        bias: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_uint,
        condition: *const clingo_literal_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an edge directive."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] node_u the start vertex of the edge"]
    #[doc = "! @param[in] node_v the end vertex of the edge"]
    #[doc = "! @param[in] condition the condition under which the edge is part of the graph"]
    #[doc = "! @param[in] size the number of atoms in the condition"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_backend_acyc_edge(
        backend: *mut clingo_backend_t,
        node_u: ::std::os::raw::c_int,
        node_v: ::std::os::raw::c_int,
        condition: *const clingo_literal_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get a fresh atom to be used in aspif directives."]
    #[doc = "!"]
    #[doc = "! @param[in] backend the target backend"]
    #[doc = "! @param[in] symbol optional symbol to associate the atom with"]
    #[doc = "! @param[out] atom the resulting atom"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_backend_add_atom(
        backend: *mut clingo_backend_t,
        symbol: *mut clingo_symbol_t,
        atom: *mut clingo_atom_t,
    ) -> bool;
}
#[doc = "!< the entry is a (string) value"]
pub const clingo_configuration_type_clingo_configuration_type_value: clingo_configuration_type = 1;
#[doc = "!< the entry is an array"]
pub const clingo_configuration_type_clingo_configuration_type_array: clingo_configuration_type = 2;
#[doc = "!< the entry is a map"]
pub const clingo_configuration_type_clingo_configuration_type_map: clingo_configuration_type = 4;
#[doc = "! Enumeration for entries of the configuration."]
pub type clingo_configuration_type = u32;
#[doc = "! Bitset for values of type ::clingo_configuration_type."]
pub type clingo_configuration_type_bitset_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_configuration {
    _unused: [u8; 0],
}
#[doc = "! Handle for to the solver configuration."]
pub type clingo_configuration_t = clingo_configuration;
extern "C" {
    #[doc = "! Get the root key of the configuration."]
    #[doc = "!"]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[out] key the root key"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_root(
        configuration: *const clingo_configuration_t,
        key: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the type of a key."]
    #[doc = "!"]
    #[doc = "! @note The type is bitset, an entry can have multiple (but at least one) type."]
    #[doc = "!"]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] type the resulting type"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_type(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        type_: *mut clingo_configuration_type_bitset_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the description of an entry."]
    #[doc = "!"]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] description the description"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_description(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        description: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of an array entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_array."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_array_size(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the subkey at the given offset of an array entry."]
    #[doc = "!"]
    #[doc = "! @note Some array entries, like fore example the solver configuration, can be accessed past there actual size to add subentries."]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_array."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] offset the offset in the array"]
    #[doc = "! @param[out] subkey the resulting subkey"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_array_at(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        offset: usize,
        subkey: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of subkeys of a map entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] size the resulting number"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_map_size(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Query whether the map has a key."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map."]
    #[doc = "! @note Multiple levels can be looked up by concatenating keys with a period."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] name the name to lookup the subkey"]
    #[doc = "! @param[out] result whether the key is in the map"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_map_has_subkey(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        name: *const ::std::os::raw::c_char,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name associated with the offset-th subkey."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] offset the offset of the name"]
    #[doc = "! @param[out] name the resulting name"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_map_subkey_name(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        offset: usize,
        name: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Lookup a subkey under the given name."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map."]
    #[doc = "! @note Multiple levels can be looked up by concatenating keys with a period."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] name the name to lookup the subkey"]
    #[doc = "! @param[out] subkey the resulting subkey"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_map_at(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        name: *const ::std::os::raw::c_char,
        subkey: *mut clingo_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check whether a entry has a value."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] assigned whether the entry has a value"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_value_is_assigned(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        assigned: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of the string value of the given entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_value_get_size(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the string value of the given entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value."]
    #[doc = "! @pre The given size must be larger or equal to size of the value."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] value the resulting string value"]
    #[doc = "! @param[in] size the size of the given char array"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_value_get(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        value: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of an entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value."]
    #[doc = "! @param[in] configuration the target configuration"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] value the value to set"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_configuration_value_set(
        configuration: *mut clingo_configuration_t,
        key: clingo_id_t,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
#[doc = "!< the entry is invalid (has neither of the types below)"]
pub const clingo_statistics_type_clingo_statistics_type_empty: clingo_statistics_type = 0;
#[doc = "!< the entry is a (double) value"]
pub const clingo_statistics_type_clingo_statistics_type_value: clingo_statistics_type = 1;
#[doc = "!< the entry is an array"]
pub const clingo_statistics_type_clingo_statistics_type_array: clingo_statistics_type = 2;
#[doc = "!< the entry is a map"]
pub const clingo_statistics_type_clingo_statistics_type_map: clingo_statistics_type = 3;
#[doc = "! Enumeration for entries of the statistics."]
pub type clingo_statistics_type = u32;
#[doc = "! Corresponding type to ::clingo_statistics_type."]
pub type clingo_statistics_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_statistic {
    _unused: [u8; 0],
}
#[doc = "! Handle for the solver statistics."]
pub type clingo_statistics_t = clingo_statistic;
extern "C" {
    #[doc = "! Get the root key of the statistics."]
    #[doc = "!"]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[out] key the root key"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_root(statistics: *const clingo_statistics_t, key: *mut u64) -> bool;
}
extern "C" {
    #[doc = "! Get the type of a key."]
    #[doc = "!"]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] type the resulting type"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_type(
        statistics: *const clingo_statistics_t,
        key: u64,
        type_: *mut clingo_statistics_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the size of an array entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_array."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] size the resulting size"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_array_size(
        statistics: *const clingo_statistics_t,
        key: u64,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the subkey at the given offset of an array entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_array."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] offset the offset in the array"]
    #[doc = "! @param[out] subkey the resulting subkey"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_array_at(
        statistics: *const clingo_statistics_t,
        key: u64,
        offset: usize,
        subkey: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Create the subkey at the end of an array entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_array."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] type the type of the new subkey"]
    #[doc = "! @param[out] subkey the resulting subkey"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_array_push(
        statistics: *mut clingo_statistics_t,
        key: u64,
        type_: clingo_statistics_type_t,
        subkey: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of subkeys of a map entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] size the resulting number"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_map_size(
        statistics: *const clingo_statistics_t,
        key: u64,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Test if the given map contains a specific subkey."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] name name of the subkey"]
    #[doc = "! @param[out] result true if the map has a subkey with the given name"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_map_has_subkey(
        statistics: *const clingo_statistics_t,
        key: u64,
        name: *const ::std::os::raw::c_char,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the name associated with the offset-th subkey."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] offset the offset of the name"]
    #[doc = "! @param[out] name the resulting name"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_map_subkey_name(
        statistics: *const clingo_statistics_t,
        key: u64,
        offset: usize,
        name: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Lookup a subkey under the given name."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map."]
    #[doc = "! @note Multiple levels can be looked up by concatenating keys with a period."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] name the name to lookup the subkey"]
    #[doc = "! @param[out] subkey the resulting subkey"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_map_at(
        statistics: *const clingo_statistics_t,
        key: u64,
        name: *const ::std::os::raw::c_char,
        subkey: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a subkey with the given name."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[in] name the name of the new subkey"]
    #[doc = "! @param[in] type the type of the new subkey"]
    #[doc = "! @param[out] subkey the index of the resulting subkey"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_map_add_subkey(
        statistics: *mut clingo_statistics_t,
        key: u64,
        name: *const ::std::os::raw::c_char,
        type_: clingo_statistics_type_t,
        subkey: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the value of the given entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_value."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] value the resulting value"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_value_get(
        statistics: *const clingo_statistics_t,
        key: u64,
        value: *mut f64,
    ) -> bool;
}
extern "C" {
    #[doc = "! Set the value of the given entry."]
    #[doc = "!"]
    #[doc = "! @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_value."]
    #[doc = "! @param[in] statistics the target statistics"]
    #[doc = "! @param[in] key the key"]
    #[doc = "! @param[out] value the new value"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_statistics_value_set(
        statistics: *mut clingo_statistics_t,
        key: u64,
        value: f64,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_solve_control {
    _unused: [u8; 0],
}
#[doc = "! Object to add clauses during search."]
pub type clingo_solve_control_t = clingo_solve_control;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_model {
    _unused: [u8; 0],
}
#[doc = "! Object representing a model."]
pub type clingo_model_t = clingo_model;
#[doc = "!< The model represents a stable model."]
pub const clingo_model_type_clingo_model_type_stable_model: clingo_model_type = 0;
#[doc = "!< The model represents a set of brave consequences."]
pub const clingo_model_type_clingo_model_type_brave_consequences: clingo_model_type = 1;
#[doc = "!< The model represents a set of cautious consequences."]
pub const clingo_model_type_clingo_model_type_cautious_consequences: clingo_model_type = 2;
#[doc = "! Enumeration for the different model types."]
pub type clingo_model_type = u32;
#[doc = "! Corresponding type to ::clingo_model_type."]
pub type clingo_model_type_t = ::std::os::raw::c_int;
#[doc = "!< Select CSP assignments."]
pub const clingo_show_type_clingo_show_type_csp: clingo_show_type = 1;
#[doc = "!< Select shown atoms and terms."]
pub const clingo_show_type_clingo_show_type_shown: clingo_show_type = 2;
#[doc = "!< Select all atoms."]
pub const clingo_show_type_clingo_show_type_atoms: clingo_show_type = 4;
#[doc = "!< Select all terms."]
pub const clingo_show_type_clingo_show_type_terms: clingo_show_type = 8;
#[doc = "!< Select everything."]
pub const clingo_show_type_clingo_show_type_all: clingo_show_type = 15;
#[doc = "!< Select false instead of true atoms (::clingo_show_type_atoms) or terms (::clingo_show_type_terms)."]
pub const clingo_show_type_clingo_show_type_complement: clingo_show_type = 16;
#[doc = "! Enumeration of bit flags to select symbols in models."]
pub type clingo_show_type = u32;
#[doc = "! Corresponding type to ::clingo_show_type."]
pub type clingo_show_type_bitset_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "! Get the type of the model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[out] type the type of the model"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_type(model: *const clingo_model_t, type_: *mut clingo_model_type_t)
        -> bool;
}
extern "C" {
    #[doc = "! Get the running number of the model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[out] number the number of the model"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_number(model: *const clingo_model_t, number: *mut u64) -> bool;
}
extern "C" {
    #[doc = "! Get the number of symbols of the selected types in the model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[in] show which symbols to select"]
    #[doc = "! @param[out] size the number symbols"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_model_symbols_size(
        model: *const clingo_model_t,
        show: clingo_show_type_bitset_t,
        size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the symbols of the selected types in the model."]
    #[doc = "!"]
    #[doc = "! @note CSP assignments are represented using functions with name \"$\""]
    #[doc = "! where the first argument is the name of the CSP variable and the second one its"]
    #[doc = "! value."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[in] show which symbols to select"]
    #[doc = "! @param[out] symbols the resulting symbols"]
    #[doc = "! @param[in] size the number of selected symbols"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if the size is too small"]
    #[doc = "!"]
    #[doc = "! @see clingo_model_symbols_size()"]
    pub fn clingo_model_symbols(
        model: *const clingo_model_t,
        show: clingo_show_type_bitset_t,
        symbols: *mut clingo_symbol_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Constant time lookup to test whether an atom is in a model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[in] atom the atom to lookup"]
    #[doc = "! @param[out] contained whether the atom is contained"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_contains(
        model: *const clingo_model_t,
        atom: clingo_symbol_t,
        contained: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if a program literal is true in a model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[in] literal the literal to lookup"]
    #[doc = "! @param[out] result whether the literal is true"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_is_true(
        model: *const clingo_model_t,
        literal: clingo_literal_t,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the number of cost values of a model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[out] size the number of costs"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_cost_size(model: *const clingo_model_t, size: *mut usize) -> bool;
}
extern "C" {
    #[doc = "! Get the cost vector of a model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[out] costs the resulting costs"]
    #[doc = "! @param[in] size the number of costs"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if the size is too small"]
    #[doc = "!"]
    #[doc = "! @see clingo_model_cost_size()"]
    #[doc = "! @see clingo_model_optimality_proven()"]
    pub fn clingo_model_cost(model: *const clingo_model_t, costs: *mut i64, size: usize) -> bool;
}
extern "C" {
    #[doc = "! Whether the optimality of a model has been proven."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[out] proven whether the optimality has been proven"]
    #[doc = "! @return whether the call was successful"]
    #[doc = "!"]
    #[doc = "! @see clingo_model_cost()"]
    pub fn clingo_model_optimality_proven(model: *const clingo_model_t, proven: *mut bool) -> bool;
}
extern "C" {
    #[doc = "! Get the id of the solver thread that found the model."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[out] id the resulting thread id"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_thread_id(model: *const clingo_model_t, id: *mut clingo_id_t) -> bool;
}
extern "C" {
    #[doc = "! Add symbols to the model."]
    #[doc = "!"]
    #[doc = "! These symbols will appear in clingo's output, which means that this"]
    #[doc = "! function is only meaningful if there is an underlying clingo application."]
    #[doc = "! Only models passed to the ::clingo_solve_event_callback_t are extendable."]
    #[doc = "!"]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[in] symbols the symbols to add"]
    #[doc = "! @param[in] size the number of symbols to add"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_extend(
        model: *mut clingo_model_t,
        symbols: *const clingo_symbol_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get the associated solve control object of a model."]
    #[doc = "!"]
    #[doc = "! This object allows for adding clauses during model enumeration."]
    #[doc = "! @param[in] model the target"]
    #[doc = "! @param[out] control the resulting solve control object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_model_context(
        model: *const clingo_model_t,
        control: *mut *mut clingo_solve_control_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect the symbolic atoms."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] atoms the resulting object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_solve_control_symbolic_atoms(
        control: *const clingo_solve_control_t,
        atoms: *mut *const clingo_symbolic_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add a clause that applies to the current solving step during model"]
    #[doc = "! enumeration."]
    #[doc = "!"]
    #[doc = "! @note The @ref Propagator module provides a more sophisticated"]
    #[doc = "! interface to add clauses - even on partial assignments."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] clause array of literals representing the clause"]
    #[doc = "! @param[in] size the size of the literal array"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if adding the clause fails"]
    pub fn clingo_solve_control_add_clause(
        control: *mut clingo_solve_control_t,
        clause: *const clingo_literal_t,
        size: usize,
    ) -> bool;
}
pub const clingo_solve_result_clingo_solve_result_satisfiable: clingo_solve_result = 1;
pub const clingo_solve_result_clingo_solve_result_unsatisfiable: clingo_solve_result = 2;
pub const clingo_solve_result_clingo_solve_result_exhausted: clingo_solve_result = 4;
pub const clingo_solve_result_clingo_solve_result_interrupted: clingo_solve_result = 8;
pub type clingo_solve_result = u32;
pub type clingo_solve_result_bitset_t = ::std::os::raw::c_uint;
#[doc = "!< Enable non-blocking search."]
pub const clingo_solve_mode_clingo_solve_mode_async: clingo_solve_mode = 1;
#[doc = "!< Yield models in calls to clingo_solve_handle_model."]
pub const clingo_solve_mode_clingo_solve_mode_yield: clingo_solve_mode = 2;
#[doc = "! Enumeration of solve modes."]
pub type clingo_solve_mode = u32;
#[doc = "! Corresponding type to ::clingo_solve_mode."]
pub type clingo_solve_mode_bitset_t = ::std::os::raw::c_uint;
#[doc = "!< Issued if a model is found."]
pub const clingo_solve_event_type_clingo_solve_event_type_model: clingo_solve_event_type = 0;
#[doc = "!< Issued when the statistics can be updated."]
pub const clingo_solve_event_type_clingo_solve_event_type_statistics: clingo_solve_event_type = 1;
#[doc = "!< Issued if the search has completed."]
pub const clingo_solve_event_type_clingo_solve_event_type_finish: clingo_solve_event_type = 2;
#[doc = "! Enumeration of solve events."]
pub type clingo_solve_event_type = u32;
#[doc = "! Corresponding type to ::clingo_solve_event_type."]
pub type clingo_solve_event_type_t = ::std::os::raw::c_uint;
#[doc = "! Callback function called during search to notify when the search is finished or a model is ready."]
#[doc = "!"]
#[doc = "! If a (non-recoverable) clingo API function fails in this callback, it must return false."]
#[doc = "! In case of errors not related to clingo, set error code ::clingo_error_unknown and return false to stop solving with an error."]
#[doc = "!"]
#[doc = "! The event is either a pointer to a model, a pointer to two statistics objects (per step and accumulated statistics), or a solve result."]
#[doc = "! @attention If the search is finished, the model is NULL."]
#[doc = "!"]
#[doc = "! @param[in] event the current event."]
#[doc = "! @param[in] data user data of the callback"]
#[doc = "! @param[out] goon can be set to false to stop solving"]
#[doc = "! @return whether the call was successful"]
#[doc = "!"]
#[doc = "! @see clingo_control_solve()"]
pub type clingo_solve_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: clingo_solve_event_type_t,
        event: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        goon: *mut bool,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_solve_handle {
    _unused: [u8; 0],
}
#[doc = "! Search handle to a solve call."]
#[doc = "!"]
#[doc = "! @see clingo_control_solve()"]
pub type clingo_solve_handle_t = clingo_solve_handle;
extern "C" {
    #[doc = "! Get the next solve result."]
    #[doc = "!"]
    #[doc = "! Blocks until the result is ready."]
    #[doc = "! When yielding partial solve results can be obtained, i.e.,"]
    #[doc = "! when a model is ready, the result will be satisfiable but neither the search exhausted nor the optimality proven."]
    #[doc = "!"]
    #[doc = "! @param[in] handle the target"]
    #[doc = "! @param[out] result the solve result"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_get(
        handle: *mut clingo_solve_handle_t,
        result: *mut clingo_solve_result_bitset_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Wait for the specified amount of time to check if the next result is ready."]
    #[doc = "!"]
    #[doc = "! If the time is set to zero, this function can be used to poll if the search is still active."]
    #[doc = "! If the time is negative, the function blocks until the search is finished."]
    #[doc = "!"]
    #[doc = "! @param[in] handle the target"]
    #[doc = "! @param[in] timeout the maximum time to wait"]
    #[doc = "! @param[out] result whether the search has finished"]
    pub fn clingo_solve_handle_wait(
        handle: *mut clingo_solve_handle_t,
        timeout: f64,
        result: *mut bool,
    );
}
extern "C" {
    #[doc = "! Get the next model (or zero if there are no more models)."]
    #[doc = "!"]
    #[doc = "! @param[in] handle the target"]
    #[doc = "! @param[out] model the model (it is NULL if there are no more models)"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_model(
        handle: *mut clingo_solve_handle_t,
        model: *mut *const clingo_model_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Discards the last model and starts the search for the next one."]
    #[doc = "!"]
    #[doc = "! If the search has been started asynchronously, this function continues the search in the background."]
    #[doc = "!"]
    #[doc = "! @note This function does not block."]
    #[doc = "!"]
    #[doc = "! @param[in] handle the target"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_resume(handle: *mut clingo_solve_handle_t) -> bool;
}
extern "C" {
    #[doc = "! Stop the running search and block until done."]
    #[doc = "!"]
    #[doc = "! @param[in] handle the target"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_cancel(handle: *mut clingo_solve_handle_t) -> bool;
}
extern "C" {
    #[doc = "! Stops the running search and releases the handle."]
    #[doc = "!"]
    #[doc = "! Blocks until the search is stopped (as if an implicit cancel was called before the handle is released)."]
    #[doc = "!"]
    #[doc = "! @param[in] handle the target"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_close(handle: *mut clingo_solve_handle_t) -> bool;
}
pub const clingo_ast_comparison_operator_clingo_ast_comparison_operator_greater_than:
    clingo_ast_comparison_operator = 0;
pub const clingo_ast_comparison_operator_clingo_ast_comparison_operator_less_than:
    clingo_ast_comparison_operator = 1;
pub const clingo_ast_comparison_operator_clingo_ast_comparison_operator_less_equal:
    clingo_ast_comparison_operator = 2;
pub const clingo_ast_comparison_operator_clingo_ast_comparison_operator_greater_equal:
    clingo_ast_comparison_operator = 3;
pub const clingo_ast_comparison_operator_clingo_ast_comparison_operator_not_equal:
    clingo_ast_comparison_operator = 4;
pub const clingo_ast_comparison_operator_clingo_ast_comparison_operator_equal:
    clingo_ast_comparison_operator = 5;
#[doc = "! @addtogroup AST"]
#[doc = "! @{"]
pub type clingo_ast_comparison_operator = u32;
pub type clingo_ast_comparison_operator_t = ::std::os::raw::c_int;
pub const clingo_ast_sign_clingo_ast_sign_none: clingo_ast_sign = 0;
pub const clingo_ast_sign_clingo_ast_sign_negation: clingo_ast_sign = 1;
pub const clingo_ast_sign_clingo_ast_sign_double_negation: clingo_ast_sign = 2;
pub type clingo_ast_sign = u32;
pub type clingo_ast_sign_t = ::std::os::raw::c_int;
pub const clingo_ast_term_type_clingo_ast_term_type_symbol: clingo_ast_term_type = 0;
pub const clingo_ast_term_type_clingo_ast_term_type_variable: clingo_ast_term_type = 1;
pub const clingo_ast_term_type_clingo_ast_term_type_unary_operation: clingo_ast_term_type = 2;
pub const clingo_ast_term_type_clingo_ast_term_type_binary_operation: clingo_ast_term_type = 3;
pub const clingo_ast_term_type_clingo_ast_term_type_interval: clingo_ast_term_type = 4;
pub const clingo_ast_term_type_clingo_ast_term_type_function: clingo_ast_term_type = 5;
pub const clingo_ast_term_type_clingo_ast_term_type_external_function: clingo_ast_term_type = 6;
pub const clingo_ast_term_type_clingo_ast_term_type_pool: clingo_ast_term_type = 7;
pub type clingo_ast_term_type = u32;
pub type clingo_ast_term_type_t = ::std::os::raw::c_int;
pub type clingo_ast_unary_operation_t = clingo_ast_unary_operation;
pub type clingo_ast_binary_operation_t = clingo_ast_binary_operation;
pub type clingo_ast_interval_t = clingo_ast_interval;
pub type clingo_ast_function_t = clingo_ast_function;
pub type clingo_ast_pool_t = clingo_ast_pool;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_term {
    pub location: clingo_location_t,
    pub type_: clingo_ast_term_type_t,
    pub __bindgen_anon_1: clingo_ast_term__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union clingo_ast_term__bindgen_ty_1 {
    pub symbol: clingo_symbol_t,
    pub variable: *const ::std::os::raw::c_char,
    pub unary_operation: *const clingo_ast_unary_operation_t,
    pub binary_operation: *const clingo_ast_binary_operation_t,
    pub interval: *const clingo_ast_interval_t,
    pub function: *const clingo_ast_function_t,
    pub external_function: *const clingo_ast_function_t,
    pub pool: *const clingo_ast_pool_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_clingo_ast_term__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_term__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(clingo_ast_term__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_term__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_term__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_term__bindgen_ty_1>())).symbol as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_term__bindgen_ty_1),
            "::",
            stringify!(symbol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_term__bindgen_ty_1>())).variable as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_term__bindgen_ty_1),
            "::",
            stringify!(variable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_term__bindgen_ty_1>())).unary_operation as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_term__bindgen_ty_1),
            "::",
            stringify!(unary_operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_term__bindgen_ty_1>())).binary_operation as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_term__bindgen_ty_1),
            "::",
            stringify!(binary_operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_term__bindgen_ty_1>())).interval as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_term__bindgen_ty_1),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_term__bindgen_ty_1>())).function as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_term__bindgen_ty_1),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_term__bindgen_ty_1>())).external_function as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_term__bindgen_ty_1),
            "::",
            stringify!(external_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_term__bindgen_ty_1>())).pool as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_term__bindgen_ty_1),
            "::",
            stringify!(pool)
        )
    );
}
#[test]
fn bindgen_test_layout_clingo_ast_term() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_term>(),
        64usize,
        concat!("Size of: ", stringify!(clingo_ast_term))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_term>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_term))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_term>())).location as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_term),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_term>())).type_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_term),
            "::",
            stringify!(type_)
        )
    );
}
pub type clingo_ast_term_t = clingo_ast_term;
pub const clingo_ast_unary_operator_clingo_ast_unary_operator_minus: clingo_ast_unary_operator = 0;
pub const clingo_ast_unary_operator_clingo_ast_unary_operator_negation: clingo_ast_unary_operator =
    1;
pub const clingo_ast_unary_operator_clingo_ast_unary_operator_absolute: clingo_ast_unary_operator =
    2;
pub type clingo_ast_unary_operator = u32;
pub type clingo_ast_unary_operator_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_unary_operation {
    pub unary_operator: clingo_ast_unary_operator_t,
    pub argument: clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_unary_operation() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_unary_operation>(),
        72usize,
        concat!("Size of: ", stringify!(clingo_ast_unary_operation))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_unary_operation>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_unary_operation))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_unary_operation>())).unary_operator as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_unary_operation),
            "::",
            stringify!(unary_operator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_unary_operation>())).argument as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_unary_operation),
            "::",
            stringify!(argument)
        )
    );
}
pub const clingo_ast_binary_operator_clingo_ast_binary_operator_xor: clingo_ast_binary_operator = 0;
pub const clingo_ast_binary_operator_clingo_ast_binary_operator_or: clingo_ast_binary_operator = 1;
pub const clingo_ast_binary_operator_clingo_ast_binary_operator_and: clingo_ast_binary_operator = 2;
pub const clingo_ast_binary_operator_clingo_ast_binary_operator_plus: clingo_ast_binary_operator =
    3;
pub const clingo_ast_binary_operator_clingo_ast_binary_operator_minus: clingo_ast_binary_operator =
    4;
pub const clingo_ast_binary_operator_clingo_ast_binary_operator_multiplication:
    clingo_ast_binary_operator = 5;
pub const clingo_ast_binary_operator_clingo_ast_binary_operator_division:
    clingo_ast_binary_operator = 6;
pub const clingo_ast_binary_operator_clingo_ast_binary_operator_modulo: clingo_ast_binary_operator =
    7;
pub const clingo_ast_binary_operator_clingo_ast_binary_operator_power: clingo_ast_binary_operator =
    8;
pub type clingo_ast_binary_operator = u32;
pub type clingo_ast_binary_operator_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_binary_operation {
    pub binary_operator: clingo_ast_binary_operator_t,
    pub left: clingo_ast_term_t,
    pub right: clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_binary_operation() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_binary_operation>(),
        136usize,
        concat!("Size of: ", stringify!(clingo_ast_binary_operation))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_binary_operation>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_binary_operation))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_binary_operation>())).binary_operator as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_binary_operation),
            "::",
            stringify!(binary_operator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_binary_operation>())).left as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_binary_operation),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_binary_operation>())).right as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_binary_operation),
            "::",
            stringify!(right)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_interval {
    pub left: clingo_ast_term_t,
    pub right: clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_interval() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_interval>(),
        128usize,
        concat!("Size of: ", stringify!(clingo_ast_interval))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_interval>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_interval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_interval>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_interval),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_interval>())).right as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_interval),
            "::",
            stringify!(right)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_function {
    pub name: *const ::std::os::raw::c_char,
    pub arguments: *const clingo_ast_term_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_function() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_function>(),
        24usize,
        concat!("Size of: ", stringify!(clingo_ast_function))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_function>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_function))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_function>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_function),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_function>())).arguments as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_function),
            "::",
            stringify!(arguments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_function>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_function),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_pool {
    pub arguments: *const clingo_ast_term_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_pool() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_pool>(),
        16usize,
        concat!("Size of: ", stringify!(clingo_ast_pool))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_pool>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_pool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_pool>())).arguments as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_pool),
            "::",
            stringify!(arguments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_pool>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_pool),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_csp_product_term {
    pub location: clingo_location_t,
    pub coefficient: clingo_ast_term_t,
    pub variable: *const clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_csp_product_term() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_csp_product_term>(),
        120usize,
        concat!("Size of: ", stringify!(clingo_ast_csp_product_term))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_csp_product_term>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_csp_product_term))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_csp_product_term>())).location as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_csp_product_term),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_csp_product_term>())).coefficient as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_csp_product_term),
            "::",
            stringify!(coefficient)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_csp_product_term>())).variable as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_csp_product_term),
            "::",
            stringify!(variable)
        )
    );
}
pub type clingo_ast_csp_product_term_t = clingo_ast_csp_product_term;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_csp_sum_term {
    pub location: clingo_location_t,
    pub terms: *const clingo_ast_csp_product_term_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_csp_sum_term() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_csp_sum_term>(),
        64usize,
        concat!("Size of: ", stringify!(clingo_ast_csp_sum_term))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_csp_sum_term>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_csp_sum_term))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_csp_sum_term>())).location as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_csp_sum_term),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_csp_sum_term>())).terms as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_csp_sum_term),
            "::",
            stringify!(terms)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_csp_sum_term>())).size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_csp_sum_term),
            "::",
            stringify!(size)
        )
    );
}
pub type clingo_ast_csp_sum_term_t = clingo_ast_csp_sum_term;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_csp_guard {
    pub comparison: clingo_ast_comparison_operator_t,
    pub term: clingo_ast_csp_sum_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_csp_guard() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_csp_guard>(),
        72usize,
        concat!("Size of: ", stringify!(clingo_ast_csp_guard))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_csp_guard>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_csp_guard))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_csp_guard>())).comparison as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_csp_guard),
            "::",
            stringify!(comparison)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_csp_guard>())).term as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_csp_guard),
            "::",
            stringify!(term)
        )
    );
}
pub type clingo_ast_csp_guard_t = clingo_ast_csp_guard;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_csp_literal {
    pub term: clingo_ast_csp_sum_term_t,
    pub guards: *const clingo_ast_csp_guard_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_csp_literal() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_csp_literal>(),
        80usize,
        concat!("Size of: ", stringify!(clingo_ast_csp_literal))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_csp_literal>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_csp_literal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_csp_literal>())).term as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_csp_literal),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_csp_literal>())).guards as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_csp_literal),
            "::",
            stringify!(guards)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_csp_literal>())).size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_csp_literal),
            "::",
            stringify!(size)
        )
    );
}
pub type clingo_ast_csp_literal_t = clingo_ast_csp_literal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_id {
    pub location: clingo_location_t,
    pub id: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_clingo_ast_id() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_id>(),
        56usize,
        concat!("Size of: ", stringify!(clingo_ast_id))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_id>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_id>())).location as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_id),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_id>())).id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_id),
            "::",
            stringify!(id)
        )
    );
}
pub type clingo_ast_id_t = clingo_ast_id;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_comparison {
    pub comparison: clingo_ast_comparison_operator_t,
    pub left: clingo_ast_term_t,
    pub right: clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_comparison() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_comparison>(),
        136usize,
        concat!("Size of: ", stringify!(clingo_ast_comparison))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_comparison>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_comparison))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_comparison>())).comparison as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_comparison),
            "::",
            stringify!(comparison)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_comparison>())).left as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_comparison),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_comparison>())).right as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_comparison),
            "::",
            stringify!(right)
        )
    );
}
pub type clingo_ast_comparison_t = clingo_ast_comparison;
pub const clingo_ast_literal_type_clingo_ast_literal_type_boolean: clingo_ast_literal_type = 0;
pub const clingo_ast_literal_type_clingo_ast_literal_type_symbolic: clingo_ast_literal_type = 1;
pub const clingo_ast_literal_type_clingo_ast_literal_type_comparison: clingo_ast_literal_type = 2;
pub const clingo_ast_literal_type_clingo_ast_literal_type_csp: clingo_ast_literal_type = 3;
pub type clingo_ast_literal_type = u32;
pub type clingo_ast_literal_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_literal {
    pub location: clingo_location_t,
    pub sign: clingo_ast_sign_t,
    pub type_: clingo_ast_literal_type_t,
    pub __bindgen_anon_1: clingo_ast_literal__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union clingo_ast_literal__bindgen_ty_1 {
    pub boolean: bool,
    pub symbol: *const clingo_ast_term_t,
    pub comparison: *const clingo_ast_comparison_t,
    pub csp_literal: *const clingo_ast_csp_literal_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_clingo_ast_literal__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_literal__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(clingo_ast_literal__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_literal__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(clingo_ast_literal__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_literal__bindgen_ty_1>())).boolean as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_literal__bindgen_ty_1),
            "::",
            stringify!(boolean)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_literal__bindgen_ty_1>())).symbol as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_literal__bindgen_ty_1),
            "::",
            stringify!(symbol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_literal__bindgen_ty_1>())).comparison as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_literal__bindgen_ty_1),
            "::",
            stringify!(comparison)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_literal__bindgen_ty_1>())).csp_literal as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_literal__bindgen_ty_1),
            "::",
            stringify!(csp_literal)
        )
    );
}
#[test]
fn bindgen_test_layout_clingo_ast_literal() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_literal>(),
        64usize,
        concat!("Size of: ", stringify!(clingo_ast_literal))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_literal>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_literal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_literal>())).location as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_literal),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_literal>())).sign as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_literal),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_literal>())).type_ as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_literal),
            "::",
            stringify!(type_)
        )
    );
}
pub type clingo_ast_literal_t = clingo_ast_literal;
pub const clingo_ast_aggregate_function_clingo_ast_aggregate_function_count:
    clingo_ast_aggregate_function = 0;
pub const clingo_ast_aggregate_function_clingo_ast_aggregate_function_sum:
    clingo_ast_aggregate_function = 1;
pub const clingo_ast_aggregate_function_clingo_ast_aggregate_function_sump:
    clingo_ast_aggregate_function = 2;
pub const clingo_ast_aggregate_function_clingo_ast_aggregate_function_min:
    clingo_ast_aggregate_function = 3;
pub const clingo_ast_aggregate_function_clingo_ast_aggregate_function_max:
    clingo_ast_aggregate_function = 4;
pub type clingo_ast_aggregate_function = u32;
pub type clingo_ast_aggregate_function_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_aggregate_guard {
    pub comparison: clingo_ast_comparison_operator_t,
    pub term: clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_aggregate_guard() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_aggregate_guard>(),
        72usize,
        concat!("Size of: ", stringify!(clingo_ast_aggregate_guard))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_aggregate_guard>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_aggregate_guard))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_aggregate_guard>())).comparison as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_aggregate_guard),
            "::",
            stringify!(comparison)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_aggregate_guard>())).term as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_aggregate_guard),
            "::",
            stringify!(term)
        )
    );
}
pub type clingo_ast_aggregate_guard_t = clingo_ast_aggregate_guard;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_conditional_literal {
    pub literal: clingo_ast_literal_t,
    pub condition: *const clingo_ast_literal_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_conditional_literal() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_conditional_literal>(),
        80usize,
        concat!("Size of: ", stringify!(clingo_ast_conditional_literal))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_conditional_literal>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_conditional_literal))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_conditional_literal>())).literal as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_conditional_literal),
            "::",
            stringify!(literal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_conditional_literal>())).condition as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_conditional_literal),
            "::",
            stringify!(condition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_conditional_literal>())).size as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_conditional_literal),
            "::",
            stringify!(size)
        )
    );
}
pub type clingo_ast_conditional_literal_t = clingo_ast_conditional_literal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_aggregate {
    pub elements: *const clingo_ast_conditional_literal_t,
    pub size: usize,
    pub left_guard: *const clingo_ast_aggregate_guard_t,
    pub right_guard: *const clingo_ast_aggregate_guard_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_aggregate() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_aggregate>(),
        32usize,
        concat!("Size of: ", stringify!(clingo_ast_aggregate))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_aggregate>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_aggregate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_aggregate>())).elements as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_aggregate),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_aggregate>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_aggregate),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_aggregate>())).left_guard as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_aggregate),
            "::",
            stringify!(left_guard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_aggregate>())).right_guard as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_aggregate),
            "::",
            stringify!(right_guard)
        )
    );
}
pub type clingo_ast_aggregate_t = clingo_ast_aggregate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_body_aggregate_element {
    pub tuple: *const clingo_ast_term_t,
    pub tuple_size: usize,
    pub condition: *const clingo_ast_literal_t,
    pub condition_size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_body_aggregate_element() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_body_aggregate_element>(),
        32usize,
        concat!("Size of: ", stringify!(clingo_ast_body_aggregate_element))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_body_aggregate_element>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(clingo_ast_body_aggregate_element)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_aggregate_element>())).tuple as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_aggregate_element),
            "::",
            stringify!(tuple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_aggregate_element>())).tuple_size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_aggregate_element),
            "::",
            stringify!(tuple_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_aggregate_element>())).condition as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_aggregate_element),
            "::",
            stringify!(condition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_aggregate_element>())).condition_size as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_aggregate_element),
            "::",
            stringify!(condition_size)
        )
    );
}
pub type clingo_ast_body_aggregate_element_t = clingo_ast_body_aggregate_element;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_body_aggregate {
    pub function: clingo_ast_aggregate_function_t,
    pub elements: *const clingo_ast_body_aggregate_element_t,
    pub size: usize,
    pub left_guard: *const clingo_ast_aggregate_guard_t,
    pub right_guard: *const clingo_ast_aggregate_guard_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_body_aggregate() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_body_aggregate>(),
        40usize,
        concat!("Size of: ", stringify!(clingo_ast_body_aggregate))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_body_aggregate>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_body_aggregate))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_aggregate>())).function as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_aggregate),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_aggregate>())).elements as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_aggregate),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_body_aggregate>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_aggregate),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_aggregate>())).left_guard as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_aggregate),
            "::",
            stringify!(left_guard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_aggregate>())).right_guard as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_aggregate),
            "::",
            stringify!(right_guard)
        )
    );
}
pub type clingo_ast_body_aggregate_t = clingo_ast_body_aggregate;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_head_aggregate_element {
    pub tuple: *const clingo_ast_term_t,
    pub tuple_size: usize,
    pub conditional_literal: clingo_ast_conditional_literal_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_head_aggregate_element() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_head_aggregate_element>(),
        96usize,
        concat!("Size of: ", stringify!(clingo_ast_head_aggregate_element))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_head_aggregate_element>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(clingo_ast_head_aggregate_element)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_head_aggregate_element>())).tuple as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_aggregate_element),
            "::",
            stringify!(tuple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_head_aggregate_element>())).tuple_size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_aggregate_element),
            "::",
            stringify!(tuple_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_head_aggregate_element>())).conditional_literal
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_aggregate_element),
            "::",
            stringify!(conditional_literal)
        )
    );
}
pub type clingo_ast_head_aggregate_element_t = clingo_ast_head_aggregate_element;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_head_aggregate {
    pub function: clingo_ast_aggregate_function_t,
    pub elements: *const clingo_ast_head_aggregate_element_t,
    pub size: usize,
    pub left_guard: *const clingo_ast_aggregate_guard_t,
    pub right_guard: *const clingo_ast_aggregate_guard_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_head_aggregate() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_head_aggregate>(),
        40usize,
        concat!("Size of: ", stringify!(clingo_ast_head_aggregate))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_head_aggregate>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_head_aggregate))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_head_aggregate>())).function as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_aggregate),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_head_aggregate>())).elements as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_aggregate),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_head_aggregate>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_aggregate),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_head_aggregate>())).left_guard as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_aggregate),
            "::",
            stringify!(left_guard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_head_aggregate>())).right_guard as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_aggregate),
            "::",
            stringify!(right_guard)
        )
    );
}
pub type clingo_ast_head_aggregate_t = clingo_ast_head_aggregate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_disjunction {
    pub elements: *const clingo_ast_conditional_literal_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_disjunction() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_disjunction>(),
        16usize,
        concat!("Size of: ", stringify!(clingo_ast_disjunction))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_disjunction>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_disjunction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_disjunction>())).elements as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_disjunction),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_disjunction>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_disjunction),
            "::",
            stringify!(size)
        )
    );
}
pub type clingo_ast_disjunction_t = clingo_ast_disjunction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_disjoint_element {
    pub location: clingo_location_t,
    pub tuple: *const clingo_ast_term_t,
    pub tuple_size: usize,
    pub term: clingo_ast_csp_sum_term_t,
    pub condition: *const clingo_ast_literal_t,
    pub condition_size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_disjoint_element() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_disjoint_element>(),
        144usize,
        concat!("Size of: ", stringify!(clingo_ast_disjoint_element))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_disjoint_element>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_disjoint_element))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_disjoint_element>())).location as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_disjoint_element),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_disjoint_element>())).tuple as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_disjoint_element),
            "::",
            stringify!(tuple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_disjoint_element>())).tuple_size as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_disjoint_element),
            "::",
            stringify!(tuple_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_disjoint_element>())).term as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_disjoint_element),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_disjoint_element>())).condition as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_disjoint_element),
            "::",
            stringify!(condition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_disjoint_element>())).condition_size as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_disjoint_element),
            "::",
            stringify!(condition_size)
        )
    );
}
pub type clingo_ast_disjoint_element_t = clingo_ast_disjoint_element;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_disjoint {
    pub elements: *const clingo_ast_disjoint_element_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_disjoint() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_disjoint>(),
        16usize,
        concat!("Size of: ", stringify!(clingo_ast_disjoint))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_disjoint>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_disjoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_disjoint>())).elements as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_disjoint),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_disjoint>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_disjoint),
            "::",
            stringify!(size)
        )
    );
}
pub type clingo_ast_disjoint_t = clingo_ast_disjoint;
pub const clingo_ast_theory_term_type_clingo_ast_theory_term_type_symbol:
    clingo_ast_theory_term_type = 0;
pub const clingo_ast_theory_term_type_clingo_ast_theory_term_type_variable:
    clingo_ast_theory_term_type = 1;
pub const clingo_ast_theory_term_type_clingo_ast_theory_term_type_tuple:
    clingo_ast_theory_term_type = 2;
pub const clingo_ast_theory_term_type_clingo_ast_theory_term_type_list:
    clingo_ast_theory_term_type = 3;
pub const clingo_ast_theory_term_type_clingo_ast_theory_term_type_set: clingo_ast_theory_term_type =
    4;
pub const clingo_ast_theory_term_type_clingo_ast_theory_term_type_function:
    clingo_ast_theory_term_type = 5;
pub const clingo_ast_theory_term_type_clingo_ast_theory_term_type_unparsed_term:
    clingo_ast_theory_term_type = 6;
pub type clingo_ast_theory_term_type = u32;
pub type clingo_ast_theory_term_type_t = ::std::os::raw::c_int;
pub type clingo_ast_theory_function_t = clingo_ast_theory_function;
pub type clingo_ast_theory_term_array_t = clingo_ast_theory_term_array;
pub type clingo_ast_theory_unparsed_term_t = clingo_ast_theory_unparsed_term;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_theory_term {
    pub location: clingo_location_t,
    pub type_: clingo_ast_theory_term_type_t,
    pub __bindgen_anon_1: clingo_ast_theory_term__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union clingo_ast_theory_term__bindgen_ty_1 {
    pub symbol: clingo_symbol_t,
    pub variable: *const ::std::os::raw::c_char,
    pub tuple: *const clingo_ast_theory_term_array_t,
    pub list: *const clingo_ast_theory_term_array_t,
    pub set: *const clingo_ast_theory_term_array_t,
    pub function: *const clingo_ast_theory_function_t,
    pub unparsed_term: *const clingo_ast_theory_unparsed_term_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_term__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_theory_term__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(clingo_ast_theory_term__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_theory_term__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(clingo_ast_theory_term__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_term__bindgen_ty_1>())).symbol as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term__bindgen_ty_1),
            "::",
            stringify!(symbol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_term__bindgen_ty_1>())).variable as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term__bindgen_ty_1),
            "::",
            stringify!(variable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_term__bindgen_ty_1>())).tuple as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term__bindgen_ty_1),
            "::",
            stringify!(tuple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_term__bindgen_ty_1>())).list as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term__bindgen_ty_1),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_term__bindgen_ty_1>())).set as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term__bindgen_ty_1),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_term__bindgen_ty_1>())).function as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term__bindgen_ty_1),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_term__bindgen_ty_1>())).unparsed_term
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term__bindgen_ty_1),
            "::",
            stringify!(unparsed_term)
        )
    );
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_term() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_theory_term>(),
        64usize,
        concat!("Size of: ", stringify!(clingo_ast_theory_term))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_theory_term>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_theory_term))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_theory_term>())).location as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_theory_term>())).type_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term),
            "::",
            stringify!(type_)
        )
    );
}
pub type clingo_ast_theory_term_t = clingo_ast_theory_term;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_theory_term_array {
    pub terms: *const clingo_ast_theory_term_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_term_array() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_theory_term_array>(),
        16usize,
        concat!("Size of: ", stringify!(clingo_ast_theory_term_array))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_theory_term_array>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_theory_term_array))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_term_array>())).terms as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term_array),
            "::",
            stringify!(terms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_term_array>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term_array),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_theory_function {
    pub name: *const ::std::os::raw::c_char,
    pub arguments: *const clingo_ast_theory_term_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_function() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_theory_function>(),
        24usize,
        concat!("Size of: ", stringify!(clingo_ast_theory_function))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_theory_function>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_theory_function))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_theory_function>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_function),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_function>())).arguments as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_function),
            "::",
            stringify!(arguments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_theory_function>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_function),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_theory_unparsed_term_element {
    pub operators: *const *const ::std::os::raw::c_char,
    pub size: usize,
    pub term: clingo_ast_theory_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_unparsed_term_element() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_theory_unparsed_term_element>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(clingo_ast_theory_unparsed_term_element)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_theory_unparsed_term_element>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(clingo_ast_theory_unparsed_term_element)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_unparsed_term_element>())).operators
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_unparsed_term_element),
            "::",
            stringify!(operators)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_unparsed_term_element>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_unparsed_term_element),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_unparsed_term_element>())).term as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_unparsed_term_element),
            "::",
            stringify!(term)
        )
    );
}
pub type clingo_ast_theory_unparsed_term_element_t = clingo_ast_theory_unparsed_term_element;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_theory_unparsed_term {
    pub elements: *const clingo_ast_theory_unparsed_term_element_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_unparsed_term() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_theory_unparsed_term>(),
        16usize,
        concat!("Size of: ", stringify!(clingo_ast_theory_unparsed_term))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_theory_unparsed_term>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_theory_unparsed_term))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_unparsed_term>())).elements as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_unparsed_term),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_unparsed_term>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_unparsed_term),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_theory_atom_element {
    pub tuple: *const clingo_ast_theory_term_t,
    pub tuple_size: usize,
    pub condition: *const clingo_ast_literal_t,
    pub condition_size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_atom_element() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_theory_atom_element>(),
        32usize,
        concat!("Size of: ", stringify!(clingo_ast_theory_atom_element))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_theory_atom_element>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_theory_atom_element))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_atom_element>())).tuple as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_atom_element),
            "::",
            stringify!(tuple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_atom_element>())).tuple_size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_atom_element),
            "::",
            stringify!(tuple_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_atom_element>())).condition as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_atom_element),
            "::",
            stringify!(condition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_atom_element>())).condition_size as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_atom_element),
            "::",
            stringify!(condition_size)
        )
    );
}
pub type clingo_ast_theory_atom_element_t = clingo_ast_theory_atom_element;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_theory_guard {
    pub operator_name: *const ::std::os::raw::c_char,
    pub term: clingo_ast_theory_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_guard() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_theory_guard>(),
        72usize,
        concat!("Size of: ", stringify!(clingo_ast_theory_guard))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_theory_guard>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_theory_guard))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_guard>())).operator_name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_guard),
            "::",
            stringify!(operator_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_theory_guard>())).term as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_guard),
            "::",
            stringify!(term)
        )
    );
}
pub type clingo_ast_theory_guard_t = clingo_ast_theory_guard;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_theory_atom {
    pub term: clingo_ast_term_t,
    pub elements: *const clingo_ast_theory_atom_element_t,
    pub size: usize,
    pub guard: *const clingo_ast_theory_guard_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_atom() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_theory_atom>(),
        88usize,
        concat!("Size of: ", stringify!(clingo_ast_theory_atom))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_theory_atom>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_theory_atom))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_theory_atom>())).term as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_atom),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_theory_atom>())).elements as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_atom),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_theory_atom>())).size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_atom),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_theory_atom>())).guard as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_atom),
            "::",
            stringify!(guard)
        )
    );
}
pub type clingo_ast_theory_atom_t = clingo_ast_theory_atom;
pub const clingo_ast_head_literal_type_clingo_ast_head_literal_type_literal:
    clingo_ast_head_literal_type = 0;
pub const clingo_ast_head_literal_type_clingo_ast_head_literal_type_disjunction:
    clingo_ast_head_literal_type = 1;
pub const clingo_ast_head_literal_type_clingo_ast_head_literal_type_aggregate:
    clingo_ast_head_literal_type = 2;
pub const clingo_ast_head_literal_type_clingo_ast_head_literal_type_head_aggregate:
    clingo_ast_head_literal_type = 3;
pub const clingo_ast_head_literal_type_clingo_ast_head_literal_type_theory_atom:
    clingo_ast_head_literal_type = 4;
pub type clingo_ast_head_literal_type = u32;
pub type clingo_ast_head_literal_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_head_literal {
    pub location: clingo_location_t,
    pub type_: clingo_ast_head_literal_type_t,
    pub __bindgen_anon_1: clingo_ast_head_literal__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union clingo_ast_head_literal__bindgen_ty_1 {
    pub literal: *const clingo_ast_literal_t,
    pub disjunction: *const clingo_ast_disjunction_t,
    pub aggregate: *const clingo_ast_aggregate_t,
    pub head_aggregate: *const clingo_ast_head_aggregate_t,
    pub theory_atom: *const clingo_ast_theory_atom_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_clingo_ast_head_literal__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_head_literal__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(clingo_ast_head_literal__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_head_literal__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(clingo_ast_head_literal__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_head_literal__bindgen_ty_1>())).literal as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_literal__bindgen_ty_1),
            "::",
            stringify!(literal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_head_literal__bindgen_ty_1>())).disjunction
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_literal__bindgen_ty_1),
            "::",
            stringify!(disjunction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_head_literal__bindgen_ty_1>())).aggregate as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_literal__bindgen_ty_1),
            "::",
            stringify!(aggregate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_head_literal__bindgen_ty_1>())).head_aggregate
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_literal__bindgen_ty_1),
            "::",
            stringify!(head_aggregate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_head_literal__bindgen_ty_1>())).theory_atom
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_literal__bindgen_ty_1),
            "::",
            stringify!(theory_atom)
        )
    );
}
#[test]
fn bindgen_test_layout_clingo_ast_head_literal() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_head_literal>(),
        64usize,
        concat!("Size of: ", stringify!(clingo_ast_head_literal))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_head_literal>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_head_literal))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_head_literal>())).location as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_literal),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_head_literal>())).type_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_head_literal),
            "::",
            stringify!(type_)
        )
    );
}
pub type clingo_ast_head_literal_t = clingo_ast_head_literal;
pub const clingo_ast_body_literal_type_clingo_ast_body_literal_type_literal:
    clingo_ast_body_literal_type = 0;
pub const clingo_ast_body_literal_type_clingo_ast_body_literal_type_conditional:
    clingo_ast_body_literal_type = 1;
pub const clingo_ast_body_literal_type_clingo_ast_body_literal_type_aggregate:
    clingo_ast_body_literal_type = 2;
pub const clingo_ast_body_literal_type_clingo_ast_body_literal_type_body_aggregate:
    clingo_ast_body_literal_type = 3;
pub const clingo_ast_body_literal_type_clingo_ast_body_literal_type_theory_atom:
    clingo_ast_body_literal_type = 4;
pub const clingo_ast_body_literal_type_clingo_ast_body_literal_type_disjoint:
    clingo_ast_body_literal_type = 5;
pub type clingo_ast_body_literal_type = u32;
pub type clingo_ast_body_literal_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_body_literal {
    pub location: clingo_location_t,
    pub sign: clingo_ast_sign_t,
    pub type_: clingo_ast_body_literal_type_t,
    pub __bindgen_anon_1: clingo_ast_body_literal__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union clingo_ast_body_literal__bindgen_ty_1 {
    pub literal: *const clingo_ast_literal_t,
    pub conditional: *const clingo_ast_conditional_literal_t,
    pub aggregate: *const clingo_ast_aggregate_t,
    pub body_aggregate: *const clingo_ast_body_aggregate_t,
    pub theory_atom: *const clingo_ast_theory_atom_t,
    pub disjoint: *const clingo_ast_disjoint_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_clingo_ast_body_literal__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_body_literal__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(clingo_ast_body_literal__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_body_literal__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(clingo_ast_body_literal__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_literal__bindgen_ty_1>())).literal as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_literal__bindgen_ty_1),
            "::",
            stringify!(literal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_literal__bindgen_ty_1>())).conditional
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_literal__bindgen_ty_1),
            "::",
            stringify!(conditional)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_literal__bindgen_ty_1>())).aggregate as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_literal__bindgen_ty_1),
            "::",
            stringify!(aggregate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_literal__bindgen_ty_1>())).body_aggregate
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_literal__bindgen_ty_1),
            "::",
            stringify!(body_aggregate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_literal__bindgen_ty_1>())).theory_atom
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_literal__bindgen_ty_1),
            "::",
            stringify!(theory_atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_literal__bindgen_ty_1>())).disjoint as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_literal__bindgen_ty_1),
            "::",
            stringify!(disjoint)
        )
    );
}
#[test]
fn bindgen_test_layout_clingo_ast_body_literal() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_body_literal>(),
        64usize,
        concat!("Size of: ", stringify!(clingo_ast_body_literal))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_body_literal>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_body_literal))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_body_literal>())).location as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_literal),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_body_literal>())).sign as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_literal),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_body_literal>())).type_ as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_body_literal),
            "::",
            stringify!(type_)
        )
    );
}
pub type clingo_ast_body_literal_t = clingo_ast_body_literal;
pub const clingo_ast_theory_operator_type_clingo_ast_theory_operator_type_unary:
    clingo_ast_theory_operator_type = 0;
pub const clingo_ast_theory_operator_type_clingo_ast_theory_operator_type_binary_left:
    clingo_ast_theory_operator_type = 1;
pub const clingo_ast_theory_operator_type_clingo_ast_theory_operator_type_binary_right:
    clingo_ast_theory_operator_type = 2;
pub type clingo_ast_theory_operator_type = u32;
pub type clingo_ast_theory_operator_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_theory_operator_definition {
    pub location: clingo_location_t,
    pub name: *const ::std::os::raw::c_char,
    pub priority: ::std::os::raw::c_uint,
    pub type_: clingo_ast_theory_operator_type_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_operator_definition() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_theory_operator_definition>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(clingo_ast_theory_operator_definition)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_theory_operator_definition>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(clingo_ast_theory_operator_definition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_operator_definition>())).location as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_operator_definition),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_operator_definition>())).name as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_operator_definition),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_operator_definition>())).priority as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_operator_definition),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_operator_definition>())).type_ as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_operator_definition),
            "::",
            stringify!(type_)
        )
    );
}
pub type clingo_ast_theory_operator_definition_t = clingo_ast_theory_operator_definition;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_theory_term_definition {
    pub location: clingo_location_t,
    pub name: *const ::std::os::raw::c_char,
    pub operators: *const clingo_ast_theory_operator_definition_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_term_definition() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_theory_term_definition>(),
        72usize,
        concat!("Size of: ", stringify!(clingo_ast_theory_term_definition))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_theory_term_definition>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(clingo_ast_theory_term_definition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_term_definition>())).location as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term_definition),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_term_definition>())).name as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term_definition),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_term_definition>())).operators as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term_definition),
            "::",
            stringify!(operators)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_term_definition>())).size as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_term_definition),
            "::",
            stringify!(size)
        )
    );
}
pub type clingo_ast_theory_term_definition_t = clingo_ast_theory_term_definition;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_theory_guard_definition {
    pub term: *const ::std::os::raw::c_char,
    pub operators: *const *const ::std::os::raw::c_char,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_guard_definition() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_theory_guard_definition>(),
        24usize,
        concat!("Size of: ", stringify!(clingo_ast_theory_guard_definition))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_theory_guard_definition>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(clingo_ast_theory_guard_definition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_guard_definition>())).term as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_guard_definition),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_guard_definition>())).operators as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_guard_definition),
            "::",
            stringify!(operators)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_guard_definition>())).size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_guard_definition),
            "::",
            stringify!(size)
        )
    );
}
pub type clingo_ast_theory_guard_definition_t = clingo_ast_theory_guard_definition;
pub const clingo_ast_theory_atom_definition_type_clingo_ast_theory_atom_definition_type_head:
    clingo_ast_theory_atom_definition_type = 0;
pub const clingo_ast_theory_atom_definition_type_clingo_ast_theory_atom_definition_type_body:
    clingo_ast_theory_atom_definition_type = 1;
pub const clingo_ast_theory_atom_definition_type_clingo_ast_theory_atom_definition_type_any:
    clingo_ast_theory_atom_definition_type = 2;
pub const clingo_ast_theory_atom_definition_type_clingo_ast_theory_atom_definition_type_directive : clingo_ast_theory_atom_definition_type = 3 ;
pub type clingo_ast_theory_atom_definition_type = u32;
pub type clingo_ast_theory_atom_definition_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_theory_atom_definition {
    pub location: clingo_location_t,
    pub type_: clingo_ast_theory_atom_definition_type_t,
    pub name: *const ::std::os::raw::c_char,
    pub arity: ::std::os::raw::c_uint,
    pub elements: *const ::std::os::raw::c_char,
    pub guard: *const clingo_ast_theory_guard_definition_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_atom_definition() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_theory_atom_definition>(),
        88usize,
        concat!("Size of: ", stringify!(clingo_ast_theory_atom_definition))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_theory_atom_definition>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(clingo_ast_theory_atom_definition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_atom_definition>())).location as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_atom_definition),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_atom_definition>())).type_ as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_atom_definition),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_atom_definition>())).name as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_atom_definition),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_atom_definition>())).arity as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_atom_definition),
            "::",
            stringify!(arity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_atom_definition>())).elements as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_atom_definition),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_atom_definition>())).guard as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_atom_definition),
            "::",
            stringify!(guard)
        )
    );
}
pub type clingo_ast_theory_atom_definition_t = clingo_ast_theory_atom_definition;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_theory_definition {
    pub name: *const ::std::os::raw::c_char,
    pub terms: *const clingo_ast_theory_term_definition_t,
    pub terms_size: usize,
    pub atoms: *const clingo_ast_theory_atom_definition_t,
    pub atoms_size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_definition() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_theory_definition>(),
        40usize,
        concat!("Size of: ", stringify!(clingo_ast_theory_definition))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_theory_definition>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_theory_definition))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_definition>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_definition),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_definition>())).terms as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_definition),
            "::",
            stringify!(terms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_definition>())).terms_size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_definition),
            "::",
            stringify!(terms_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_definition>())).atoms as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_definition),
            "::",
            stringify!(atoms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_theory_definition>())).atoms_size as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_theory_definition),
            "::",
            stringify!(atoms_size)
        )
    );
}
pub type clingo_ast_theory_definition_t = clingo_ast_theory_definition;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_rule {
    pub head: clingo_ast_head_literal_t,
    pub body: *const clingo_ast_body_literal_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_rule() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_rule>(),
        80usize,
        concat!("Size of: ", stringify!(clingo_ast_rule))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_rule>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_rule))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_rule>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_rule),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_rule>())).body as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_rule),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_rule>())).size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_rule),
            "::",
            stringify!(size)
        )
    );
}
pub type clingo_ast_rule_t = clingo_ast_rule;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_definition {
    pub name: *const ::std::os::raw::c_char,
    pub value: clingo_ast_term_t,
    pub is_default: bool,
}
#[test]
fn bindgen_test_layout_clingo_ast_definition() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_definition>(),
        80usize,
        concat!("Size of: ", stringify!(clingo_ast_definition))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_definition>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_definition))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_definition>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_definition),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_definition>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_definition),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_definition>())).is_default as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_definition),
            "::",
            stringify!(is_default)
        )
    );
}
pub type clingo_ast_definition_t = clingo_ast_definition;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_show_signature {
    pub signature: clingo_signature_t,
    pub csp: bool,
}
#[test]
fn bindgen_test_layout_clingo_ast_show_signature() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_show_signature>(),
        16usize,
        concat!("Size of: ", stringify!(clingo_ast_show_signature))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_show_signature>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_show_signature))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_show_signature>())).signature as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_show_signature),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_show_signature>())).csp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_show_signature),
            "::",
            stringify!(csp)
        )
    );
}
pub type clingo_ast_show_signature_t = clingo_ast_show_signature;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_show_term {
    pub term: clingo_ast_term_t,
    pub body: *const clingo_ast_body_literal_t,
    pub size: usize,
    pub csp: bool,
}
#[test]
fn bindgen_test_layout_clingo_ast_show_term() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_show_term>(),
        88usize,
        concat!("Size of: ", stringify!(clingo_ast_show_term))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_show_term>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_show_term))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_show_term>())).term as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_show_term),
            "::",
            stringify!(term)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_show_term>())).body as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_show_term),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_show_term>())).size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_show_term),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_show_term>())).csp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_show_term),
            "::",
            stringify!(csp)
        )
    );
}
pub type clingo_ast_show_term_t = clingo_ast_show_term;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_defined {
    pub signature: clingo_signature_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_defined() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_defined>(),
        8usize,
        concat!("Size of: ", stringify!(clingo_ast_defined))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_defined>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_defined))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_defined>())).signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_defined),
            "::",
            stringify!(signature)
        )
    );
}
pub type clingo_ast_defined_t = clingo_ast_defined;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_minimize {
    pub weight: clingo_ast_term_t,
    pub priority: clingo_ast_term_t,
    pub tuple: *const clingo_ast_term_t,
    pub tuple_size: usize,
    pub body: *const clingo_ast_body_literal_t,
    pub body_size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_minimize() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_minimize>(),
        160usize,
        concat!("Size of: ", stringify!(clingo_ast_minimize))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_minimize>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_minimize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_minimize>())).weight as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_minimize),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_minimize>())).priority as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_minimize),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_minimize>())).tuple as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_minimize),
            "::",
            stringify!(tuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_minimize>())).tuple_size as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_minimize),
            "::",
            stringify!(tuple_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_minimize>())).body as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_minimize),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_minimize>())).body_size as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_minimize),
            "::",
            stringify!(body_size)
        )
    );
}
pub type clingo_ast_minimize_t = clingo_ast_minimize;
pub const clingo_ast_script_type_clingo_ast_script_type_lua: clingo_ast_script_type = 0;
pub const clingo_ast_script_type_clingo_ast_script_type_python: clingo_ast_script_type = 1;
pub type clingo_ast_script_type = u32;
pub type clingo_ast_script_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_script {
    pub type_: clingo_ast_script_type_t,
    pub code: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_clingo_ast_script() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_script>(),
        16usize,
        concat!("Size of: ", stringify!(clingo_ast_script))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_script>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_script))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_script>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_script),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_script>())).code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_script),
            "::",
            stringify!(code)
        )
    );
}
pub type clingo_ast_script_t = clingo_ast_script;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ast_program {
    pub name: *const ::std::os::raw::c_char,
    pub parameters: *const clingo_ast_id_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_program() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_program>(),
        24usize,
        concat!("Size of: ", stringify!(clingo_ast_program))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_program>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_program))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_program>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_program),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_program>())).parameters as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_program),
            "::",
            stringify!(parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_program>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_program),
            "::",
            stringify!(size)
        )
    );
}
pub type clingo_ast_program_t = clingo_ast_program;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_external {
    pub atom: clingo_ast_term_t,
    pub body: *const clingo_ast_body_literal_t,
    pub size: usize,
    pub type_: clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_external() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_external>(),
        144usize,
        concat!("Size of: ", stringify!(clingo_ast_external))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_external>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_external))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_external>())).atom as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_external),
            "::",
            stringify!(atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_external>())).body as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_external),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_external>())).size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_external),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_external>())).type_ as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_external),
            "::",
            stringify!(type_)
        )
    );
}
pub type clingo_ast_external_t = clingo_ast_external;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_edge {
    pub u: clingo_ast_term_t,
    pub v: clingo_ast_term_t,
    pub body: *const clingo_ast_body_literal_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_edge() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_edge>(),
        144usize,
        concat!("Size of: ", stringify!(clingo_ast_edge))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_edge>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_edge))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_edge>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_edge),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_edge>())).v as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_edge),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_edge>())).body as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_edge),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_edge>())).size as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_edge),
            "::",
            stringify!(size)
        )
    );
}
pub type clingo_ast_edge_t = clingo_ast_edge;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_heuristic {
    pub atom: clingo_ast_term_t,
    pub body: *const clingo_ast_body_literal_t,
    pub size: usize,
    pub bias: clingo_ast_term_t,
    pub priority: clingo_ast_term_t,
    pub modifier: clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_heuristic() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_heuristic>(),
        272usize,
        concat!("Size of: ", stringify!(clingo_ast_heuristic))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_heuristic>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_heuristic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_heuristic>())).atom as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_heuristic),
            "::",
            stringify!(atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_heuristic>())).body as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_heuristic),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_heuristic>())).size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_heuristic),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_heuristic>())).bias as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_heuristic),
            "::",
            stringify!(bias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_heuristic>())).priority as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_heuristic),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_heuristic>())).modifier as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_heuristic),
            "::",
            stringify!(modifier)
        )
    );
}
pub type clingo_ast_heuristic_t = clingo_ast_heuristic;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_project {
    pub atom: clingo_ast_term_t,
    pub body: *const clingo_ast_body_literal_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_project() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_project>(),
        80usize,
        concat!("Size of: ", stringify!(clingo_ast_project))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_project>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_project))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_project>())).atom as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_project),
            "::",
            stringify!(atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_project>())).body as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_project),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_project>())).size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_project),
            "::",
            stringify!(size)
        )
    );
}
pub type clingo_ast_project_t = clingo_ast_project;
pub const clingo_ast_statement_type_clingo_ast_statement_type_rule: clingo_ast_statement_type = 0;
pub const clingo_ast_statement_type_clingo_ast_statement_type_const: clingo_ast_statement_type = 1;
pub const clingo_ast_statement_type_clingo_ast_statement_type_show_signature:
    clingo_ast_statement_type = 2;
pub const clingo_ast_statement_type_clingo_ast_statement_type_show_term: clingo_ast_statement_type =
    3;
pub const clingo_ast_statement_type_clingo_ast_statement_type_minimize: clingo_ast_statement_type =
    4;
pub const clingo_ast_statement_type_clingo_ast_statement_type_script: clingo_ast_statement_type = 5;
pub const clingo_ast_statement_type_clingo_ast_statement_type_program: clingo_ast_statement_type =
    6;
pub const clingo_ast_statement_type_clingo_ast_statement_type_external: clingo_ast_statement_type =
    7;
pub const clingo_ast_statement_type_clingo_ast_statement_type_edge: clingo_ast_statement_type = 8;
pub const clingo_ast_statement_type_clingo_ast_statement_type_heuristic: clingo_ast_statement_type =
    9;
pub const clingo_ast_statement_type_clingo_ast_statement_type_project_atom:
    clingo_ast_statement_type = 10;
pub const clingo_ast_statement_type_clingo_ast_statement_type_project_atom_signature:
    clingo_ast_statement_type = 11;
pub const clingo_ast_statement_type_clingo_ast_statement_type_theory_definition:
    clingo_ast_statement_type = 12;
pub const clingo_ast_statement_type_clingo_ast_statement_type_defined: clingo_ast_statement_type =
    13;
pub type clingo_ast_statement_type = u32;
pub type clingo_ast_statement_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clingo_ast_statement {
    pub location: clingo_location_t,
    pub type_: clingo_ast_statement_type_t,
    pub __bindgen_anon_1: clingo_ast_statement__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union clingo_ast_statement__bindgen_ty_1 {
    pub rule: *const clingo_ast_rule_t,
    pub definition: *const clingo_ast_definition_t,
    pub show_signature: *const clingo_ast_show_signature_t,
    pub show_term: *const clingo_ast_show_term_t,
    pub minimize: *const clingo_ast_minimize_t,
    pub script: *const clingo_ast_script_t,
    pub program: *const clingo_ast_program_t,
    pub external: *const clingo_ast_external_t,
    pub edge: *const clingo_ast_edge_t,
    pub heuristic: *const clingo_ast_heuristic_t,
    pub project_atom: *const clingo_ast_project_t,
    pub project_signature: clingo_signature_t,
    pub theory_definition: *const clingo_ast_theory_definition_t,
    pub defined: *const clingo_ast_defined_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_clingo_ast_statement__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_statement__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(clingo_ast_statement__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_statement__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(clingo_ast_statement__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_statement__bindgen_ty_1>())).rule as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement__bindgen_ty_1),
            "::",
            stringify!(rule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_statement__bindgen_ty_1>())).definition as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement__bindgen_ty_1),
            "::",
            stringify!(definition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_statement__bindgen_ty_1>())).show_signature
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement__bindgen_ty_1),
            "::",
            stringify!(show_signature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_statement__bindgen_ty_1>())).show_term as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement__bindgen_ty_1),
            "::",
            stringify!(show_term)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_statement__bindgen_ty_1>())).minimize as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement__bindgen_ty_1),
            "::",
            stringify!(minimize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_statement__bindgen_ty_1>())).script as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement__bindgen_ty_1),
            "::",
            stringify!(script)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_statement__bindgen_ty_1>())).program as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement__bindgen_ty_1),
            "::",
            stringify!(program)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_statement__bindgen_ty_1>())).external as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement__bindgen_ty_1),
            "::",
            stringify!(external)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_statement__bindgen_ty_1>())).edge as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement__bindgen_ty_1),
            "::",
            stringify!(edge)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_statement__bindgen_ty_1>())).heuristic as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement__bindgen_ty_1),
            "::",
            stringify!(heuristic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_statement__bindgen_ty_1>())).project_atom as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement__bindgen_ty_1),
            "::",
            stringify!(project_atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_statement__bindgen_ty_1>())).project_signature
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement__bindgen_ty_1),
            "::",
            stringify!(project_signature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_statement__bindgen_ty_1>())).theory_definition
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement__bindgen_ty_1),
            "::",
            stringify!(theory_definition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ast_statement__bindgen_ty_1>())).defined as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement__bindgen_ty_1),
            "::",
            stringify!(defined)
        )
    );
}
#[test]
fn bindgen_test_layout_clingo_ast_statement() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ast_statement>(),
        64usize,
        concat!("Size of: ", stringify!(clingo_ast_statement))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ast_statement>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ast_statement))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_statement>())).location as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_ast_statement>())).type_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ast_statement),
            "::",
            stringify!(type_)
        )
    );
}
pub type clingo_ast_statement_t = clingo_ast_statement;
pub type clingo_ast_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const clingo_ast_statement_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    #[doc = "! Parse the given program and return an abstract syntax tree for each statement via a callback."]
    #[doc = "!"]
    #[doc = "! @param[in] program the program in gringo syntax"]
    #[doc = "! @param[in] callback the callback reporting statements"]
    #[doc = "! @param[in] callback_data user data for the callback"]
    #[doc = "! @param[in] logger callback to report messages during parsing"]
    #[doc = "! @param[in] logger_data user data for the logger"]
    #[doc = "! @param[in] message_limit the maximum number of times the logger is called"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if parsing fails"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_parse_program(
        program: *const ::std::os::raw::c_char,
        callback: clingo_ast_callback_t,
        callback_data: *mut ::std::os::raw::c_void,
        logger: clingo_logger_t,
        logger_data: *mut ::std::os::raw::c_void,
        message_limit: ::std::os::raw::c_uint,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_program_builder {
    _unused: [u8; 0],
}
#[doc = "! Object to build non-ground programs."]
pub type clingo_program_builder_t = clingo_program_builder;
extern "C" {
    #[doc = "! Begin building a program."]
    #[doc = "!"]
    #[doc = "! @param builder the target program builder"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_program_builder_begin(builder: *mut clingo_program_builder_t) -> bool;
}
extern "C" {
    #[doc = "! Adds a statement to the program."]
    #[doc = "!"]
    #[doc = "! @attention @ref clingo_program_builder_begin() must be called before adding statements and @ref clingo_program_builder_end() must be called after all statements have been added."]
    #[doc = "! @param builder the target program builder"]
    #[doc = "! @param statement the statement to add"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime for statements of invalid form"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_program_builder_add(
        builder: *mut clingo_program_builder_t,
        statement: *const clingo_ast_statement_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! End building a program."]
    #[doc = "!"]
    #[doc = "! @param builder the target program builder"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_program_builder_end(builder: *mut clingo_program_builder_t) -> bool;
}
#[doc = "! An instance of this struct has to be registered with a solver to observe ground directives as they are passed to the solver."]
#[doc = "!"]
#[doc = "! @note This interface is closely modeled after the aspif format."]
#[doc = "! For more information please refer to the specification of the aspif format."]
#[doc = "!"]
#[doc = "! Not all callbacks have to be implemented and can be set to NULL if not needed."]
#[doc = "! If one of the callbacks in the struct fails, grounding is stopped."]
#[doc = "! If a non-recoverable clingo API call fails, a callback must return false."]
#[doc = "! Otherwise ::clingo_error_unknown should be set and false returned."]
#[doc = "!"]
#[doc = "! @see clingo_control_register_observer()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ground_program_observer {
    #[doc = "! Called once in the beginning."]
    #[doc = "!"]
    #[doc = "! If the incremental flag is true, there can be multiple calls to @ref clingo_control_solve()."]
    #[doc = "!"]
    #[doc = "! @param[in] incremental whether the program is incremental"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub init_program: ::std::option::Option<
        unsafe extern "C" fn(incremental: bool, data: *mut ::std::os::raw::c_void) -> bool,
    >,
    #[doc = "! Marks the beginning of a block of directives passed to the solver."]
    #[doc = "!"]
    #[doc = "! @see @ref end_step"]
    #[doc = "!"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub begin_step:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
    #[doc = "! Marks the end of a block of directives passed to the solver."]
    #[doc = "!"]
    #[doc = "! This function is called before solving starts."]
    #[doc = "!"]
    #[doc = "! @see @ref begin_step"]
    #[doc = "!"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub end_step:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
    #[doc = "! Observe rules passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] choice determines if the head is a choice or a disjunction"]
    #[doc = "! @param[in] head the head atoms"]
    #[doc = "! @param[in] head_size the number of atoms in the head"]
    #[doc = "! @param[in] body the body literals"]
    #[doc = "! @param[in] body_size the number of literals in the body"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub rule: ::std::option::Option<
        unsafe extern "C" fn(
            choice: bool,
            head: *const clingo_atom_t,
            head_size: usize,
            body: *const clingo_literal_t,
            body_size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe weight rules passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] choice determines if the head is a choice or a disjunction"]
    #[doc = "! @param[in] head the head atoms"]
    #[doc = "! @param[in] head_size the number of atoms in the head"]
    #[doc = "! @param[in] lower_bound the lower bound of the weight rule"]
    #[doc = "! @param[in] body the weighted body literals"]
    #[doc = "! @param[in] body_size the number of weighted literals in the body"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub weight_rule: ::std::option::Option<
        unsafe extern "C" fn(
            choice: bool,
            head: *const clingo_atom_t,
            head_size: usize,
            lower_bound: clingo_weight_t,
            body: *const clingo_weighted_literal_t,
            body_size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe minimize constraints (or weak constraints) passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] priority the priority of the constraint"]
    #[doc = "! @param[in] literals the weighted literals whose sum to minimize"]
    #[doc = "! @param[in] size the number of weighted literals"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub minimize: ::std::option::Option<
        unsafe extern "C" fn(
            priority: clingo_weight_t,
            literals: *const clingo_weighted_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe projection directives passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] atoms the atoms to project on"]
    #[doc = "! @param[in] size the number of atoms"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub project: ::std::option::Option<
        unsafe extern "C" fn(
            atoms: *const clingo_atom_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe shown atoms passed to the solver."]
    #[doc = "! \\note Facts do not have an associated aspif atom."]
    #[doc = "! The value of the atom is set to zero."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the symbolic representation of the atom"]
    #[doc = "! @param[in] atom the aspif atom (0 for facts)"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub output_atom: ::std::option::Option<
        unsafe extern "C" fn(
            symbol: clingo_symbol_t,
            atom: clingo_atom_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe shown terms passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the symbolic representation of the term"]
    #[doc = "! @param[in] condition the literals of the condition"]
    #[doc = "! @param[in] size the size of the condition"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub output_term: ::std::option::Option<
        unsafe extern "C" fn(
            symbol: clingo_symbol_t,
            condition: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe shown csp variables passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] symbol the symbolic representation of the variable"]
    #[doc = "! @param[in] value the value of the variable"]
    #[doc = "! @param[in] condition the literals of the condition"]
    #[doc = "! @param[in] size the size of the condition"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub output_csp: ::std::option::Option<
        unsafe extern "C" fn(
            symbol: clingo_symbol_t,
            value: ::std::os::raw::c_int,
            condition: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe external statements passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] atom the external atom"]
    #[doc = "! @param[in] type the type of the external statement"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub external: ::std::option::Option<
        unsafe extern "C" fn(
            atom: clingo_atom_t,
            type_: clingo_external_type_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe assumption directives passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] literals the literals to assume (positive literals are true and negative literals false for the next solve call)"]
    #[doc = "! @param[in] size the number of atoms"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub assume: ::std::option::Option<
        unsafe extern "C" fn(
            literals: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe heuristic directives passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] atom the target atom"]
    #[doc = "! @param[in] type the type of the heuristic modification"]
    #[doc = "! @param[in] bias the heuristic bias"]
    #[doc = "! @param[in] priority the heuristic priority"]
    #[doc = "! @param[in] condition the condition under which to apply the heuristic modification"]
    #[doc = "! @param[in] size the number of atoms in the condition"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub heuristic: ::std::option::Option<
        unsafe extern "C" fn(
            atom: clingo_atom_t,
            type_: clingo_heuristic_type_t,
            bias: ::std::os::raw::c_int,
            priority: ::std::os::raw::c_uint,
            condition: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe edge directives passed to the solver."]
    #[doc = "!"]
    #[doc = "! @param[in] node_u the start vertex of the edge"]
    #[doc = "! @param[in] node_v the end vertex of the edge"]
    #[doc = "! @param[in] condition the condition under which the edge is part of the graph"]
    #[doc = "! @param[in] size the number of atoms in the condition"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub acyc_edge: ::std::option::Option<
        unsafe extern "C" fn(
            node_u: ::std::os::raw::c_int,
            node_v: ::std::os::raw::c_int,
            condition: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe numeric theory terms."]
    #[doc = "!"]
    #[doc = "! @param[in] term_id the id of the term"]
    #[doc = "! @param[in] number the value of the term"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub theory_term_number: ::std::option::Option<
        unsafe extern "C" fn(
            term_id: clingo_id_t,
            number: ::std::os::raw::c_int,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe string theory terms."]
    #[doc = "!"]
    #[doc = "! @param[in] term_id the id of the term"]
    #[doc = "! @param[in] name the value of the term"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub theory_term_string: ::std::option::Option<
        unsafe extern "C" fn(
            term_id: clingo_id_t,
            name: *const ::std::os::raw::c_char,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe compound theory terms."]
    #[doc = "!"]
    #[doc = "! The name_id_or_type gives the type of the compound term:"]
    #[doc = "! - if it is -1, then it is a tuple"]
    #[doc = "! - if it is -2, then it is a set"]
    #[doc = "! - if it is -3, then it is a list"]
    #[doc = "! - otherwise, it is a function and name_id_or_type refers to the id of the name (in form of a string term)"]
    #[doc = "!"]
    #[doc = "! @param[in] term_id the id of the term"]
    #[doc = "! @param[in] name_id_or_type the name or type of the term"]
    #[doc = "! @param[in] arguments the arguments of the term"]
    #[doc = "! @param[in] size the number of arguments"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub theory_term_compound: ::std::option::Option<
        unsafe extern "C" fn(
            term_id: clingo_id_t,
            name_id_or_type: ::std::os::raw::c_int,
            arguments: *const clingo_id_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe theory elements."]
    #[doc = "!"]
    #[doc = "! @param element_id the id of the element"]
    #[doc = "! @param terms the term tuple of the element"]
    #[doc = "! @param terms_size the number of terms in the tuple"]
    #[doc = "! @param condition the condition of the elemnt"]
    #[doc = "! @param condition_size the number of literals in the condition"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub theory_element: ::std::option::Option<
        unsafe extern "C" fn(
            element_id: clingo_id_t,
            terms: *const clingo_id_t,
            terms_size: usize,
            condition: *const clingo_literal_t,
            condition_size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe theory atoms without guard."]
    #[doc = "!"]
    #[doc = "! @param[in] atom_id_or_zero the id of the atom or zero for directives"]
    #[doc = "! @param[in] term_id the term associated with the atom"]
    #[doc = "! @param[in] elements the elements of the atom"]
    #[doc = "! @param[in] size the number of elements"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub theory_atom: ::std::option::Option<
        unsafe extern "C" fn(
            atom_id_or_zero: clingo_id_t,
            term_id: clingo_id_t,
            elements: *const clingo_id_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe theory atoms with guard."]
    #[doc = "!"]
    #[doc = "! @param[in] atom_id_or_zero the id of the atom or zero for directives"]
    #[doc = "! @param[in] term_id the term associated with the atom"]
    #[doc = "! @param[in] elements the elements of the atom"]
    #[doc = "! @param[in] size the number of elements"]
    #[doc = "! @param[in] operator_id the id of the operator (a string term)"]
    #[doc = "! @param[in] right_hand_side_id the id of the term on the right hand side of the atom"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @return whether the call was successful"]
    pub theory_atom_with_guard: ::std::option::Option<
        unsafe extern "C" fn(
            atom_id_or_zero: clingo_id_t,
            term_id: clingo_id_t,
            elements: *const clingo_id_t,
            size: usize,
            operator_id: clingo_id_t,
            right_hand_side_id: clingo_id_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_clingo_ground_program_observer() {
    assert_eq!(
        ::std::mem::size_of::<clingo_ground_program_observer>(),
        160usize,
        concat!("Size of: ", stringify!(clingo_ground_program_observer))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_ground_program_observer>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_ground_program_observer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).init_program as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(init_program)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).begin_step as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(begin_step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).end_step as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(end_step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).rule as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(rule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).weight_rule as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(weight_rule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).minimize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(minimize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).project as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(project)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).output_atom as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(output_atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).output_term as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(output_term)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).output_csp as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(output_csp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).external as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(external)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).assume as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(assume)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).heuristic as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(heuristic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).acyc_edge as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(acyc_edge)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).theory_term_number
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_term_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).theory_term_string
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_term_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).theory_term_compound
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_term_compound)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).theory_element as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_element)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).theory_atom as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_ground_program_observer>())).theory_atom_with_guard
                as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_ground_program_observer),
            "::",
            stringify!(theory_atom_with_guard)
        )
    );
}
pub type clingo_ground_program_observer_t = clingo_ground_program_observer;
#[doc = "! Struct used to specify the program parts that have to be grounded."]
#[doc = "!"]
#[doc = "! Programs may be structured into parts, which can be grounded independently with ::clingo_control_ground."]
#[doc = "! Program parts are mainly interesting for incremental grounding and multi-shot solving."]
#[doc = "! For single-shot solving, program parts are not needed."]
#[doc = "!"]
#[doc = "! @note Parts of a logic program without an explicit <tt>\\#program</tt>"]
#[doc = "! specification are by default put into a program called `base` without"]
#[doc = "! arguments."]
#[doc = "!"]
#[doc = "! @see clingo_control_ground()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_part {
    #[doc = "!< name of the program part"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "!< array of parameters"]
    pub params: *const clingo_symbol_t,
    #[doc = "!< number of parameters"]
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_part() {
    assert_eq!(
        ::std::mem::size_of::<clingo_part>(),
        24usize,
        concat!("Size of: ", stringify!(clingo_part))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_part>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_part))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_part>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_part),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_part>())).params as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_part),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_part>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_part),
            "::",
            stringify!(size)
        )
    );
}
pub type clingo_part_t = clingo_part;
#[doc = "! Callback function to implement external functions."]
#[doc = "!"]
#[doc = "! If an external function of form <tt>\\@name(parameters)</tt> occurs in a logic program,"]
#[doc = "! then this function is called with its location, name, parameters, and a callback to inject symbols as arguments."]
#[doc = "! The callback can be called multiple times; all symbols passed are injected."]
#[doc = "!"]
#[doc = "! If a (non-recoverable) clingo API function fails in this callback, for example, the symbol callback, the callback must return false."]
#[doc = "! In case of errors not related to clingo, this function can set error ::clingo_error_unknown and return false to stop grounding with an error."]
#[doc = "!"]
#[doc = "! @param[in] location location from which the external function was called"]
#[doc = "! @param[in] name name of the called external function"]
#[doc = "! @param[in] arguments arguments of the called external function"]
#[doc = "! @param[in] arguments_size number of arguments"]
#[doc = "! @param[in] data user data of the callback"]
#[doc = "! @param[in] symbol_callback function to inject symbols"]
#[doc = "! @param[in] symbol_callback_data user data for the symbol callback"]
#[doc = "!            (must be passed untouched)"]
#[doc = "! @return whether the call was successful"]
#[doc = "! @see clingo_control_ground()"]
#[doc = "!"]
#[doc = "! The following example implements the external function <tt>\\@f()</tt> returning 42."]
#[doc = "! ~~~~~~~~~~~~~~~{.c}"]
#[doc = "! bool"]
#[doc = "! ground_callback(clingo_location_t const *location,"]
#[doc = "!                 char const *name,"]
#[doc = "!                 clingo_symbol_t const *arguments,"]
#[doc = "!                 size_t arguments_size,"]
#[doc = "!                 void *data,"]
#[doc = "!                 clingo_symbol_callback_t symbol_callback,"]
#[doc = "!                 void *symbol_callback_data) {"]
#[doc = "!   if (strcmp(name, \"f\") == 0 && arguments_size == 0) {"]
#[doc = "!     clingo_symbol_t sym;"]
#[doc = "!     clingo_symbol_create_number(42, &sym);"]
#[doc = "!     return symbol_callback(&sym, 1, symbol_callback_data);"]
#[doc = "!   }"]
#[doc = "!   clingo_set_error(clingo_error_runtime, \"function not found\");"]
#[doc = "!   return false;"]
#[doc = "! }"]
#[doc = "! ~~~~~~~~~~~~~~~"]
pub type clingo_ground_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        location: *const clingo_location_t,
        name: *const ::std::os::raw::c_char,
        arguments: *const clingo_symbol_t,
        arguments_size: usize,
        data: *mut ::std::os::raw::c_void,
        symbol_callback: clingo_symbol_callback_t,
        symbol_callback_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_control {
    _unused: [u8; 0],
}
#[doc = "! Control object holding grounding and solving state."]
pub type clingo_control_t = clingo_control;
extern "C" {
    #[doc = "! Create a new control object."]
    #[doc = "!"]
    #[doc = "! A control object has to be freed using clingo_control_free()."]
    #[doc = "!"]
    #[doc = "! @note Only gringo options (without <code>\\-\\-output</code>) and clasp's options are supported as arguments,"]
    #[doc = "! except basic options such as <code>\\-\\-help</code>."]
    #[doc = "! Furthermore, a control object is blocked while a search call is active;"]
    #[doc = "! you must not call any member function during search."]
    #[doc = "!"]
    #[doc = "! If the logger is NULL, messages are printed to stderr."]
    #[doc = "!"]
    #[doc = "! @param[in] arguments C string array of command line arguments"]
    #[doc = "! @param[in] arguments_size size of the arguments array"]
    #[doc = "! @param[in] logger callback functions for warnings and info messages"]
    #[doc = "! @param[in] logger_data user data for the logger callback"]
    #[doc = "! @param[in] message_limit maximum number of times the logger callback is called"]
    #[doc = "! @param[out] control resulting control object"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if argument parsing fails"]
    pub fn clingo_control_new(
        arguments: *const *const ::std::os::raw::c_char,
        arguments_size: usize,
        logger: clingo_logger_t,
        logger_data: *mut ::std::os::raw::c_void,
        message_limit: ::std::os::raw::c_uint,
        control: *mut *mut clingo_control_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Free a control object created with clingo_control_new()."]
    #[doc = "! @param[in] control the target"]
    pub fn clingo_control_free(control: *mut clingo_control_t);
}
extern "C" {
    #[doc = "! Extend the logic program with a program in a file."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] file path to the file"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if parsing or checking fails"]
    pub fn clingo_control_load(
        control: *mut clingo_control_t,
        file: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Extend the logic program with the given non-ground logic program in string form."]
    #[doc = "!"]
    #[doc = "! This function puts the given program into a block of form: <tt>\\#program name(parameters).</tt>"]
    #[doc = "!"]
    #[doc = "! After extending the logic program, the corresponding program parts are typically grounded with ::clingo_control_ground."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] name name of the program block"]
    #[doc = "! @param[in] parameters string array of parameters of the program block"]
    #[doc = "! @param[in] parameters_size number of parameters"]
    #[doc = "! @param[in] program string representation of the program"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if parsing fails"]
    pub fn clingo_control_add(
        control: *mut clingo_control_t,
        name: *const ::std::os::raw::c_char,
        parameters: *const *const ::std::os::raw::c_char,
        parameters_size: usize,
        program: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Ground the selected @link ::clingo_part parts @endlink of the current (non-ground) logic program."]
    #[doc = "!"]
    #[doc = "! After grounding, logic programs can be solved with ::clingo_control_solve()."]
    #[doc = "!"]
    #[doc = "! @note Parts of a logic program without an explicit <tt>\\#program</tt>"]
    #[doc = "! specification are by default put into a program called `base` without"]
    #[doc = "! arguments."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] parts array of parts to ground"]
    #[doc = "! @param[in] parts_size size of the parts array"]
    #[doc = "! @param[in] ground_callback callback to implement external functions"]
    #[doc = "! @param[in] ground_callback_data user data for ground_callback"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - error code of ground callback"]
    #[doc = "!"]
    #[doc = "! @see clingo_part"]
    pub fn clingo_control_ground(
        control: *mut clingo_control_t,
        parts: *const clingo_part_t,
        parts_size: usize,
        ground_callback: clingo_ground_callback_t,
        ground_callback_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "! Solve the currently @link ::clingo_control_ground grounded @endlink logic program enumerating its models."]
    #[doc = "!"]
    #[doc = "! See the @ref SolveHandle module for more information."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] mode configures the search mode"]
    #[doc = "! @param[in] assumptions array of assumptions to solve under"]
    #[doc = "! @param[in] assumptions_size number of assumptions"]
    #[doc = "! @param[in] notify the event handler to register"]
    #[doc = "! @param[in] data the user data for the event handler"]
    #[doc = "! @param[out] handle handle to the current search to enumerate models"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    #[doc = "! - ::clingo_error_runtime if solving could not be started"]
    pub fn clingo_control_solve(
        control: *mut clingo_control_t,
        mode: clingo_solve_mode_bitset_t,
        assumptions: *const clingo_literal_t,
        assumptions_size: usize,
        notify: clingo_solve_event_callback_t,
        data: *mut ::std::os::raw::c_void,
        handle: *mut *mut clingo_solve_handle_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Clean up the domains of clingo's grounding component using the solving"]
    #[doc = "! component's top level assignment."]
    #[doc = "!"]
    #[doc = "! This function removes atoms from domains that are false and marks atoms as"]
    #[doc = "! facts that are true.  With multi-shot solving, this can result in smaller"]
    #[doc = "! groundings because less rules have to be instantiated and more"]
    #[doc = "! simplifications can be applied."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_cleanup(control: *mut clingo_control_t) -> bool;
}
extern "C" {
    #[doc = "! Assign a truth value to an external atom."]
    #[doc = "!"]
    #[doc = "! If a negative literal is passed, the corresponding atom is assigned the"]
    #[doc = "! inverted truth value."]
    #[doc = "!"]
    #[doc = "! If the atom does not exist or is not external, this is a noop."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] literal literal to assign"]
    #[doc = "! @param[in] value the truth value"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_assign_external(
        control: *mut clingo_control_t,
        literal: clingo_literal_t,
        value: clingo_truth_value_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Release an external atom."]
    #[doc = "!"]
    #[doc = "! If a negative literal is passed, the corresponding atom is released."]
    #[doc = "!"]
    #[doc = "! After this call, an external atom is no longer external and subject to"]
    #[doc = "! program simplifications.  If the atom does not exist or is not external,"]
    #[doc = "! this is a noop."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] literal literal to release"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_release_external(
        control: *mut clingo_control_t,
        literal: clingo_literal_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Register a custom propagator with the control object."]
    #[doc = "!"]
    #[doc = "! If the sequential flag is set to true, the propagator is called"]
    #[doc = "! sequentially when solving with multiple threads."]
    #[doc = "!"]
    #[doc = "! See the @ref Propagator module for more information."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] propagator the propagator"]
    #[doc = "! @param[in] data user data passed to the propagator functions"]
    #[doc = "! @param[in] sequential whether the propagator should be called sequentially"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_register_propagator(
        control: *mut clingo_control_t,
        propagator: *const clingo_propagator_t,
        data: *mut ::std::os::raw::c_void,
        sequential: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if the solver has determined that the internal program representation is conflicting."]
    #[doc = "!"]
    #[doc = "! If this function returns true, solve calls will return immediately with an unsatisfiable solve result."]
    #[doc = "! Note that conflicts first have to be detected, e.g. -"]
    #[doc = "! initial unit propagation results in an empty clause,"]
    #[doc = "! or later if an empty clause is resolved during solving."]
    #[doc = "! Hence, the function might return false even if the problem is unsatisfiable."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @return whether the program representation is conflicting"]
    pub fn clingo_control_is_conflicting(control: *const clingo_control_t) -> bool;
}
extern "C" {
    #[doc = "! Get a statistics object to inspect solver statistics."]
    #[doc = "!"]
    #[doc = "! Statistics are updated after a solve call."]
    #[doc = "!"]
    #[doc = "! See the @ref Statistics module for more information."]
    #[doc = "!"]
    #[doc = "! @attention"]
    #[doc = "! The level of detail of the statistics depends on the stats option"]
    #[doc = "! (which can be set using @ref Configuration module or passed as an option when @link clingo_control_new creating the control object@endlink)."]
    #[doc = "! The default level zero only provides basic statistics,"]
    #[doc = "! level one provides extended and accumulated statistics,"]
    #[doc = "! and level two provides per-thread statistics."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] statistics the statistics object"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_statistics(
        control: *const clingo_control_t,
        statistics: *mut *const clingo_statistics_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Interrupt the active solve call (or the following solve call right at the beginning)."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    pub fn clingo_control_interrupt(control: *mut clingo_control_t);
}
extern "C" {
    #[doc = "! Get low-level access to clasp."]
    #[doc = "!"]
    #[doc = "! @attention"]
    #[doc = "! This function is intended for experimental use only and not part of the stable API."]
    #[doc = "!"]
    #[doc = "! This function may return a <code>nullptr</code>."]
    #[doc = "! Otherwise, the returned pointer can be casted to a ClaspFacade pointer."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] clasp pointer to the ClaspFacade object (may be <code>nullptr</code>)"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_clasp_facade(
        control: *mut clingo_control_t,
        clasp: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get a configuration object to change the solver configuration."]
    #[doc = "!"]
    #[doc = "! See the @ref Configuration module for more information."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] configuration the configuration object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_configuration(
        control: *mut clingo_control_t,
        configuration: *mut *mut clingo_configuration_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Configure how learnt constraints are handled during enumeration."]
    #[doc = "!"]
    #[doc = "! If the enumeration assumption is enabled, then all information learnt from"]
    #[doc = "! the solver's various enumeration modes is removed after a solve call. This"]
    #[doc = "! includes enumeration of cautious or brave consequences, enumeration of"]
    #[doc = "! answer sets with or without projection, or finding optimal models, as well"]
    #[doc = "! as clauses added with clingo_solve_control_add_clause()."]
    #[doc = "!"]
    #[doc = "! @attention For practical purposes, this option is only interesting for single-shot solving"]
    #[doc = "! or before the last solve call to squeeze out a tiny bit of performance."]
    #[doc = "! Initially, the enumeration assumption is enabled."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] enable whether to enable the assumption"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_use_enumeration_assumption(
        control: *mut clingo_control_t,
        enable: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Return the symbol for a constant definition of form: <tt>\\#const name = symbol</tt>."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] name the name of the constant"]
    #[doc = "! @param[out] symbol the resulting symbol"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_get_const(
        control: *const clingo_control_t,
        name: *const ::std::os::raw::c_char,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Check if there is a constant definition for the given constant."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] name the name of the constant"]
    #[doc = "! @param[out] exists whether a matching constant definition exists"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_runtime if constant definition does not exist"]
    #[doc = "!"]
    #[doc = "! @see clingo_control_get_const()"]
    pub fn clingo_control_has_const(
        control: *const clingo_control_t,
        name: *const ::std::os::raw::c_char,
        exists: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect symbolic atoms (the relevant Herbrand base) used"]
    #[doc = "! for grounding."]
    #[doc = "!"]
    #[doc = "! See the @ref SymbolicAtoms module for more information."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] atoms the symbolic atoms object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_symbolic_atoms(
        control: *const clingo_control_t,
        atoms: *mut *const clingo_symbolic_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to inspect theory atoms that occur in the grounding."]
    #[doc = "!"]
    #[doc = "! See the @ref TheoryAtoms module for more information."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] atoms the theory atoms object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_theory_atoms(
        control: *const clingo_control_t,
        atoms: *mut *const clingo_theory_atoms_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Register a program observer with the control object."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[in] observer the observer to register"]
    #[doc = "! @param[in] replace just pass the grounding to the observer but not the solver"]
    #[doc = "! @param[in] data user data passed to the observer functions"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_register_observer(
        control: *mut clingo_control_t,
        observer: *const clingo_ground_program_observer_t,
        replace: bool,
        data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to add ground directives to the program."]
    #[doc = "!"]
    #[doc = "! See the @ref ProgramBuilder module for more information."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] backend the backend object"]
    #[doc = "! @return whether the call was successful; might set one of the following error codes:"]
    #[doc = "! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_backend(
        control: *mut clingo_control_t,
        backend: *mut *mut clingo_backend_t,
    ) -> bool;
}
extern "C" {
    #[doc = "! Get an object to add non-ground directives to the program."]
    #[doc = "!"]
    #[doc = "! See the @ref ProgramBuilder module for more information."]
    #[doc = "!"]
    #[doc = "! @param[in] control the target"]
    #[doc = "! @param[out] builder the program builder object"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_control_program_builder(
        control: *mut clingo_control_t,
        builder: *mut *mut clingo_program_builder_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_options {
    _unused: [u8; 0],
}
#[doc = "! Object to add command-line options."]
pub type clingo_options_t = clingo_options;
#[doc = "! Callback to customize clingo main function."]
#[doc = "!"]
#[doc = "! @param[in] control corresponding control object"]
#[doc = "! @param[in] files files passed via command line arguments"]
#[doc = "! @param[in] size number of files"]
#[doc = "! @param[in] data user data for the callback"]
#[doc = "!"]
#[doc = "! @return whether the call was successful"]
pub type clingo_main_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        control: *mut clingo_control_t,
        files: *const *const ::std::os::raw::c_char,
        size: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! Callback to print a model in default format."]
#[doc = "!"]
#[doc = "! @param[in] data user data for the callback"]
#[doc = "!"]
#[doc = "! @return whether the call was successful"]
pub type clingo_default_model_printer_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>;
#[doc = "! Callback to customize model printing."]
#[doc = "!"]
#[doc = "! @param[in] model the model"]
#[doc = "! @param[in] printer the default model printer"]
#[doc = "! @param[in] printer_data user data for the printer"]
#[doc = "! @param[in] data user data for the callback"]
#[doc = "!"]
#[doc = "! @return whether the call was successful"]
pub type clingo_model_printer_t = ::std::option::Option<
    unsafe extern "C" fn(
        model: *const clingo_model_t,
        printer: clingo_default_model_printer_t,
        printer_data: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! This struct contains a set of functions to customize the clingo application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_application {
    #[doc = "!< callback to obtain program name"]
    pub program_name: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    #[doc = "!< callback to obtain version information"]
    pub version: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    #[doc = "!< callback to obtain message limit"]
    pub message_limit: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
    >,
    #[doc = "!< callback to override clingo's main function"]
    pub main: clingo_main_function_t,
    #[doc = "!< callback to override default logger"]
    pub logger: clingo_logger_t,
    #[doc = "!< callback to override default model printing"]
    pub printer: clingo_model_printer_t,
    #[doc = "!< callback to register options"]
    pub register_options: ::std::option::Option<
        unsafe extern "C" fn(
            options: *mut clingo_options_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "!< callback validate options"]
    pub validate_options:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
}
#[test]
fn bindgen_test_layout_clingo_application() {
    assert_eq!(
        ::std::mem::size_of::<clingo_application>(),
        64usize,
        concat!("Size of: ", stringify!(clingo_application))
    );
    assert_eq!(
        ::std::mem::align_of::<clingo_application>(),
        8usize,
        concat!("Alignment of ", stringify!(clingo_application))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_application>())).program_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(program_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_application>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_application>())).message_limit as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(message_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_application>())).main as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(main)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_application>())).logger as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(logger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clingo_application>())).printer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(printer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_application>())).register_options as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(register_options)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<clingo_application>())).validate_options as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(clingo_application),
            "::",
            stringify!(validate_options)
        )
    );
}
pub type clingo_application_t = clingo_application;
extern "C" {
    #[doc = "! Add an option that is processed with a custom parser."]
    #[doc = "!"]
    #[doc = "! Note that the parser also has to take care of storing the semantic value of"]
    #[doc = "! the option somewhere."]
    #[doc = "!"]
    #[doc = "! Parameter option specifies the name(s) of the option."]
    #[doc = "! For example, \"ping,p\" adds the short option \"-p\" and its long form \"--ping\"."]
    #[doc = "! It is also possible to associate an option with a help level by adding \"@l\" to the option specification."]
    #[doc = "! Options with a level greater than zero are only shown if the argument to help is greater or equal to l."]
    #[doc = "!"]
    #[doc = "! @param[in] options object to register the option with"]
    #[doc = "! @param[in] group options are grouped into sections as given by this string"]
    #[doc = "! @param[in] option specifies the command line option"]
    #[doc = "! @param[in] description the description of the option"]
    #[doc = "! @param[in] parse callback to parse the value of the option"]
    #[doc = "! @param[in] data user data for the callback"]
    #[doc = "! @param[in] multi whether the option can appear multiple times on the command-line"]
    #[doc = "! @param[in] argument optional string to change the value name in the generated help output"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_options_add(
        options: *mut clingo_options_t,
        group: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        parse: ::std::option::Option<
            unsafe extern "C" fn(
                value: *const ::std::os::raw::c_char,
                data: *mut ::std::os::raw::c_void,
            ) -> bool,
        >,
        data: *mut ::std::os::raw::c_void,
        multi: bool,
        argument: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "! Add an option that is a simple flag."]
    #[doc = "!"]
    #[doc = "! This function is similar to @ref clingo_options_add() but simpler because it only supports flags, which do not have values."]
    #[doc = "! If a flag is passed via the command-line the parameter target is set to true."]
    #[doc = "!"]
    #[doc = "! @param[in] options object to register the option with"]
    #[doc = "! @param[in] group options are grouped into sections as given by this string"]
    #[doc = "! @param[in] option specifies the command line option"]
    #[doc = "! @param[in] description the description of the option"]
    #[doc = "! @param[in] target boolean set to true if the flag is given on the command-line"]
    #[doc = "! @return whether the call was successful"]
    pub fn clingo_options_add_flag(
        options: *mut clingo_options_t,
        group: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        target: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = "! Run clingo with a customized main function (similar to python and lua embedding)."]
    #[doc = "!"]
    #[doc = "! @param[in] application struct with callbacks to override default clingo functionality"]
    #[doc = "! @param[in] arguments command line arguments"]
    #[doc = "! @param[in] size number of arguments"]
    #[doc = "! @param[in] data user data to pass to callbacks in application"]
    #[doc = "! @return exit code to return from main function"]
    pub fn clingo_main(
        application: *mut clingo_application_t,
        arguments: *const *const ::std::os::raw::c_char,
        size: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
